# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Multimodal Hidden Markov Models Library
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_xmm', [dirname(__file__)])
        except ImportError:
            import _xmm
            return _xmm
        if fp is not None:
            try:
                _mod = imp.load_module('_xmm', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _xmm = swig_import_helper()
    del swig_import_helper
else:
    import _xmm
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _xmm.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _xmm.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _xmm.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _xmm.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _xmm.SwigPyIterator_equal(self, x)

    def copy(self):
        return _xmm.SwigPyIterator_copy(self)

    def next(self):
        return _xmm.SwigPyIterator_next(self)

    def __next__(self):
        return _xmm.SwigPyIterator___next__(self)

    def previous(self):
        return _xmm.SwigPyIterator_previous(self)

    def advance(self, n):
        return _xmm.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _xmm.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _xmm.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _xmm.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _xmm.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _xmm.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _xmm.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _xmm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectord___nonzero__(self)

    def __bool__(self):
        return _xmm.vectord___bool__(self)

    def __len__(self):
        return _xmm.vectord___len__(self)

    def pop(self):
        return _xmm.vectord_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectord___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectord_append(self, x)

    def empty(self):
        return _xmm.vectord_empty(self)

    def size(self):
        return _xmm.vectord_size(self)

    def clear(self):
        return _xmm.vectord_clear(self)

    def swap(self, v):
        return _xmm.vectord_swap(self, v)

    def get_allocator(self):
        return _xmm.vectord_get_allocator(self)

    def begin(self):
        return _xmm.vectord_begin(self)

    def end(self):
        return _xmm.vectord_end(self)

    def rbegin(self):
        return _xmm.vectord_rbegin(self)

    def rend(self):
        return _xmm.vectord_rend(self)

    def pop_back(self):
        return _xmm.vectord_pop_back(self)

    def erase(self, *args):
        return _xmm.vectord_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectord(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectord_push_back(self, x)

    def front(self):
        return _xmm.vectord_front(self)

    def back(self):
        return _xmm.vectord_back(self)

    def assign(self, n, x):
        return _xmm.vectord_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectord_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectord_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectord_reserve(self, n)

    def capacity(self):
        return _xmm.vectord_capacity(self)
    __swig_destroy__ = _xmm.delete_vectord
    __del__ = lambda self: None
vectord_swigregister = _xmm.vectord_swigregister
vectord_swigregister(vectord)

class vectorf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorf, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorf___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorf___bool__(self)

    def __len__(self):
        return _xmm.vectorf___len__(self)

    def pop(self):
        return _xmm.vectorf_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorf___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorf_append(self, x)

    def empty(self):
        return _xmm.vectorf_empty(self)

    def size(self):
        return _xmm.vectorf_size(self)

    def clear(self):
        return _xmm.vectorf_clear(self)

    def swap(self, v):
        return _xmm.vectorf_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorf_get_allocator(self)

    def begin(self):
        return _xmm.vectorf_begin(self)

    def end(self):
        return _xmm.vectorf_end(self)

    def rbegin(self):
        return _xmm.vectorf_rbegin(self)

    def rend(self):
        return _xmm.vectorf_rend(self)

    def pop_back(self):
        return _xmm.vectorf_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorf_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorf(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorf_push_back(self, x)

    def front(self):
        return _xmm.vectorf_front(self)

    def back(self):
        return _xmm.vectorf_back(self)

    def assign(self, n, x):
        return _xmm.vectorf_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorf_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorf_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorf_reserve(self, n)

    def capacity(self):
        return _xmm.vectorf_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorf
    __del__ = lambda self: None
vectorf_swigregister = _xmm.vectorf_swigregister
vectorf_swigregister(vectorf)

class vectorgauss(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorgauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorgauss, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorgauss_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorgauss___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorgauss___bool__(self)

    def __len__(self):
        return _xmm.vectorgauss___len__(self)

    def pop(self):
        return _xmm.vectorgauss_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorgauss___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorgauss___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorgauss___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorgauss___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorgauss___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorgauss___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorgauss_append(self, x)

    def empty(self):
        return _xmm.vectorgauss_empty(self)

    def size(self):
        return _xmm.vectorgauss_size(self)

    def clear(self):
        return _xmm.vectorgauss_clear(self)

    def swap(self, v):
        return _xmm.vectorgauss_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorgauss_get_allocator(self)

    def begin(self):
        return _xmm.vectorgauss_begin(self)

    def end(self):
        return _xmm.vectorgauss_end(self)

    def rbegin(self):
        return _xmm.vectorgauss_rbegin(self)

    def rend(self):
        return _xmm.vectorgauss_rend(self)

    def pop_back(self):
        return _xmm.vectorgauss_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorgauss_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorgauss(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorgauss_push_back(self, x)

    def front(self):
        return _xmm.vectorgauss_front(self)

    def back(self):
        return _xmm.vectorgauss_back(self)

    def assign(self, n, x):
        return _xmm.vectorgauss_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorgauss_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorgauss_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorgauss_reserve(self, n)

    def capacity(self):
        return _xmm.vectorgauss_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorgauss
    __del__ = lambda self: None
vectorgauss_swigregister = _xmm.vectorgauss_swigregister
vectorgauss_swigregister(vectorgauss)

class vectorgmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorgmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorgmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorgmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorgmm___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorgmm___bool__(self)

    def __len__(self):
        return _xmm.vectorgmm___len__(self)

    def pop(self):
        return _xmm.vectorgmm_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorgmm___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorgmm___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorgmm___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorgmm___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorgmm___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorgmm___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorgmm_append(self, x)

    def empty(self):
        return _xmm.vectorgmm_empty(self)

    def size(self):
        return _xmm.vectorgmm_size(self)

    def clear(self):
        return _xmm.vectorgmm_clear(self)

    def swap(self, v):
        return _xmm.vectorgmm_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorgmm_get_allocator(self)

    def begin(self):
        return _xmm.vectorgmm_begin(self)

    def end(self):
        return _xmm.vectorgmm_end(self)

    def rbegin(self):
        return _xmm.vectorgmm_rbegin(self)

    def rend(self):
        return _xmm.vectorgmm_rend(self)

    def pop_back(self):
        return _xmm.vectorgmm_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorgmm_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorgmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorgmm_push_back(self, x)

    def front(self):
        return _xmm.vectorgmm_front(self)

    def back(self):
        return _xmm.vectorgmm_back(self)

    def assign(self, n, x):
        return _xmm.vectorgmm_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorgmm_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorgmm_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorgmm_reserve(self, n)

    def capacity(self):
        return _xmm.vectorgmm_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorgmm
    __del__ = lambda self: None
vectorgmm_swigregister = _xmm.vectorgmm_swigregister
vectorgmm_swigregister(vectorgmm)

class vectorhmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorhmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorhmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorhmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorhmm___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorhmm___bool__(self)

    def __len__(self):
        return _xmm.vectorhmm___len__(self)

    def pop(self):
        return _xmm.vectorhmm_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorhmm___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorhmm___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorhmm___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorhmm___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorhmm___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorhmm___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorhmm_append(self, x)

    def empty(self):
        return _xmm.vectorhmm_empty(self)

    def size(self):
        return _xmm.vectorhmm_size(self)

    def clear(self):
        return _xmm.vectorhmm_clear(self)

    def swap(self, v):
        return _xmm.vectorhmm_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorhmm_get_allocator(self)

    def begin(self):
        return _xmm.vectorhmm_begin(self)

    def end(self):
        return _xmm.vectorhmm_end(self)

    def rbegin(self):
        return _xmm.vectorhmm_rbegin(self)

    def rend(self):
        return _xmm.vectorhmm_rend(self)

    def pop_back(self):
        return _xmm.vectorhmm_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorhmm_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorhmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorhmm_push_back(self, x)

    def front(self):
        return _xmm.vectorhmm_front(self)

    def back(self):
        return _xmm.vectorhmm_back(self)

    def assign(self, n, x):
        return _xmm.vectorhmm_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorhmm_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorhmm_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorhmm_reserve(self, n)

    def capacity(self):
        return _xmm.vectorhmm_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorhmm
    __del__ = lambda self: None
vectorhmm_swigregister = _xmm.vectorhmm_swigregister
vectorhmm_swigregister(vectorhmm)

class mapgmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapgmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapgmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.mapgmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.mapgmm___nonzero__(self)

    def __bool__(self):
        return _xmm.mapgmm___bool__(self)

    def __len__(self):
        return _xmm.mapgmm___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _xmm.mapgmm___getitem__(self, key)

    def __delitem__(self, key):
        return _xmm.mapgmm___delitem__(self, key)

    def has_key(self, key):
        return _xmm.mapgmm_has_key(self, key)

    def keys(self):
        return _xmm.mapgmm_keys(self)

    def values(self):
        return _xmm.mapgmm_values(self)

    def items(self):
        return _xmm.mapgmm_items(self)

    def __contains__(self, key):
        return _xmm.mapgmm___contains__(self, key)

    def key_iterator(self):
        return _xmm.mapgmm_key_iterator(self)

    def value_iterator(self):
        return _xmm.mapgmm_value_iterator(self)

    def __setitem__(self, *args):
        return _xmm.mapgmm___setitem__(self, *args)

    def asdict(self):
        return _xmm.mapgmm_asdict(self)

    def __init__(self, *args):
        this = _xmm.new_mapgmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _xmm.mapgmm_empty(self)

    def size(self):
        return _xmm.mapgmm_size(self)

    def clear(self):
        return _xmm.mapgmm_clear(self)

    def swap(self, v):
        return _xmm.mapgmm_swap(self, v)

    def get_allocator(self):
        return _xmm.mapgmm_get_allocator(self)

    def begin(self):
        return _xmm.mapgmm_begin(self)

    def end(self):
        return _xmm.mapgmm_end(self)

    def rbegin(self):
        return _xmm.mapgmm_rbegin(self)

    def rend(self):
        return _xmm.mapgmm_rend(self)

    def count(self, x):
        return _xmm.mapgmm_count(self, x)

    def erase(self, *args):
        return _xmm.mapgmm_erase(self, *args)

    def find(self, x):
        return _xmm.mapgmm_find(self, x)

    def lower_bound(self, x):
        return _xmm.mapgmm_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.mapgmm_upper_bound(self, x)
    __swig_destroy__ = _xmm.delete_mapgmm
    __del__ = lambda self: None
mapgmm_swigregister = _xmm.mapgmm_swigregister
mapgmm_swigregister(mapgmm)

class maphmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maphmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maphmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.maphmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.maphmm___nonzero__(self)

    def __bool__(self):
        return _xmm.maphmm___bool__(self)

    def __len__(self):
        return _xmm.maphmm___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _xmm.maphmm___getitem__(self, key)

    def __delitem__(self, key):
        return _xmm.maphmm___delitem__(self, key)

    def has_key(self, key):
        return _xmm.maphmm_has_key(self, key)

    def keys(self):
        return _xmm.maphmm_keys(self)

    def values(self):
        return _xmm.maphmm_values(self)

    def items(self):
        return _xmm.maphmm_items(self)

    def __contains__(self, key):
        return _xmm.maphmm___contains__(self, key)

    def key_iterator(self):
        return _xmm.maphmm_key_iterator(self)

    def value_iterator(self):
        return _xmm.maphmm_value_iterator(self)

    def __setitem__(self, *args):
        return _xmm.maphmm___setitem__(self, *args)

    def asdict(self):
        return _xmm.maphmm_asdict(self)

    def __init__(self, *args):
        this = _xmm.new_maphmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _xmm.maphmm_empty(self)

    def size(self):
        return _xmm.maphmm_size(self)

    def clear(self):
        return _xmm.maphmm_clear(self)

    def swap(self, v):
        return _xmm.maphmm_swap(self, v)

    def get_allocator(self):
        return _xmm.maphmm_get_allocator(self)

    def begin(self):
        return _xmm.maphmm_begin(self)

    def end(self):
        return _xmm.maphmm_end(self)

    def rbegin(self):
        return _xmm.maphmm_rbegin(self)

    def rend(self):
        return _xmm.maphmm_rend(self)

    def count(self, x):
        return _xmm.maphmm_count(self, x)

    def erase(self, *args):
        return _xmm.maphmm_erase(self, *args)

    def find(self, x):
        return _xmm.maphmm_find(self, x)

    def lower_bound(self, x):
        return _xmm.maphmm_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.maphmm_upper_bound(self, x)
    __swig_destroy__ = _xmm.delete_maphmm
    __del__ = lambda self: None
maphmm_swigregister = _xmm.maphmm_swigregister
maphmm_swigregister(maphmm)


_xmm.NONE_swigconstant(_xmm)
NONE = _xmm.NONE

_xmm.SHARED_MEMORY_swigconstant(_xmm)
SHARED_MEMORY = _xmm.SHARED_MEMORY

_xmm.BIMODAL_swigconstant(_xmm)
BIMODAL = _xmm.BIMODAL

_xmm.HIERARCHICAL_swigconstant(_xmm)
HIERARCHICAL = _xmm.HIERARCHICAL
class Listener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listener, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_Listener
    __del__ = lambda self: None

    def notify(self, attribute):
        return _xmm.Listener_notify(self, attribute)
Listener_swigregister = _xmm.Listener_swigregister
Listener_swigregister(Listener)
cvar = _xmm.cvar
NULLVEC_FLOAT = cvar.NULLVEC_FLOAT
NULLVEC_DOUBLE = cvar.NULLVEC_DOUBLE

class Writable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Writable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Writable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_Writable
    __del__ = lambda self: None

    def to_json(self):
        return _xmm.Writable_to_json(self)

    def from_json(self, root):
        return _xmm.Writable_from_json(self, root)

    def writeFile(self, fileName):
        return _xmm.Writable_writeFile(self, fileName)

    def readFile(self, fileName):
        return _xmm.Writable_readFile(self, fileName)

    def __str__(self):
        return _xmm.Writable___str__(self)
Writable_swigregister = _xmm.Writable_swigregister
Writable_swigregister(Writable)

class Phrase(Writable):
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Phrase, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Phrase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _xmm.new_Phrase(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_Phrase
    __del__ = lambda self: None

    def is_empty(self):
        return _xmm.Phrase_is_empty(self)

    def __eq__(self, src):
        return _xmm.Phrase___eq__(self, src)

    def __ne__(self, src):
        return _xmm.Phrase___ne__(self, src)

    def length(self):
        return _xmm.Phrase_length(self)

    def trim(self, *args):
        return _xmm.Phrase_trim(self, *args)

    def dimension(self):
        return _xmm.Phrase_dimension(self)

    def dimension_input(self):
        return _xmm.Phrase_dimension_input(self)

    def dimension_output(self):
        return _xmm.Phrase_dimension_output(self)

    def set_dimension(self, dimension):
        return _xmm.Phrase_set_dimension(self, dimension)

    def set_dimension_input(self, dimension_input):
        return _xmm.Phrase_set_dimension_input(self, dimension_input)

    def connect(self, *args):
        return _xmm.Phrase_connect(self, *args)

    def connect_input(self, pointer_to_data, length):
        return _xmm.Phrase_connect_input(self, pointer_to_data, length)

    def connect_output(self, pointer_to_data, length):
        return _xmm.Phrase_connect_output(self, pointer_to_data, length)

    def disconnect(self):
        return _xmm.Phrase_disconnect(self)

    def record(self, observation):
        return _xmm.Phrase_record(self, observation)

    def record_input(self, observation):
        return _xmm.Phrase_record_input(self, observation)

    def record_output(self, observation):
        return _xmm.Phrase_record_output(self, observation)

    def clear(self):
        return _xmm.Phrase_clear(self)

    def at(self, index, dim):
        return _xmm.Phrase_at(self, index, dim)

    def __call__(self, index, dim):
        return _xmm.Phrase___call__(self, index, dim)

    def get_dataPointer(self, index):
        return _xmm.Phrase_get_dataPointer(self, index)

    def get_dataPointer_input(self, index):
        return _xmm.Phrase_get_dataPointer_input(self, index)

    def get_dataPointer_output(self, index):
        return _xmm.Phrase_get_dataPointer_output(self, index)

    def to_json(self):
        return _xmm.Phrase_to_json(self)

    def from_json(self, root):
        return _xmm.Phrase_from_json(self, root)

    def mean(self):
        return _xmm.Phrase_mean(self)

    def variance(self):
        return _xmm.Phrase_variance(self)
Phrase_swigregister = _xmm.Phrase_swigregister
Phrase_swigregister(Phrase)
PHRASE_DEFAULT_DIMENSION = cvar.PHRASE_DEFAULT_DIMENSION
PHRASE_ALLOC_BLOCKSIZE = cvar.PHRASE_ALLOC_BLOCKSIZE

class Label(Writable):
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Label, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Label, name)
    __repr__ = _swig_repr
    INT = _xmm.Label_INT
    SYM = _xmm.Label_SYM
    __swig_setmethods__["type"] = _xmm.Label_type_set
    __swig_getmethods__["type"] = _xmm.Label_type_get
    if _newclass:
        type = _swig_property(_xmm.Label_type_get, _xmm.Label_type_set)
    __swig_destroy__ = _xmm.delete_Label
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _xmm.new_Label(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __eq__(self, src):
        return _xmm.Label___eq__(self, src)

    def __ne__(self, src):
        return _xmm.Label___ne__(self, src)

    def __lt__(self, src):
        return _xmm.Label___lt__(self, src)

    def __le__(self, src):
        return _xmm.Label___le__(self, src)

    def __gt__(self, src):
        return _xmm.Label___gt__(self, src)

    def __ge__(self, src):
        return _xmm.Label___ge__(self, src)

    def getInt(self):
        return _xmm.Label_getInt(self)

    def getSym(self):
        return _xmm.Label_getSym(self)

    def setInt(self, l):
        return _xmm.Label_setInt(self, l)

    def trySetInt(self, l):
        return _xmm.Label_trySetInt(self, l)

    def setSym(self, *args):
        return _xmm.Label_setSym(self, *args)

    def to_json(self):
        return _xmm.Label_to_json(self)

    def from_json(self, root):
        return _xmm.Label_from_json(self, root)

    def as_string(self):
        return _xmm.Label_as_string(self)
Label_swigregister = _xmm.Label_swigregister
Label_swigregister(Label)


def is_number(s):
    return _xmm.is_number(s)
is_number = _xmm.is_number

def to_int(s):
    return _xmm.to_int(s)
to_int = _xmm.to_int
class TrainingSet(Writable):
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrainingSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TrainingSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _xmm.new_TrainingSet(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_TrainingSet
    __del__ = lambda self: None

    def is_bimodal(self):
        return _xmm.TrainingSet_is_bimodal(self)

    def is_empty(self):
        return _xmm.TrainingSet_is_empty(self)

    def size(self):
        return _xmm.TrainingSet_size(self)

    def has_changed(self):
        return _xmm.TrainingSet_has_changed(self)

    def set_unchanged(self):
        return _xmm.TrainingSet_set_unchanged(self)

    def add_listener(self, listener):
        return _xmm.TrainingSet_add_listener(self, listener)

    def remove_listener(self, listener):
        return _xmm.TrainingSet_remove_listener(self, listener)

    def dimension(self):
        return _xmm.TrainingSet_dimension(self)

    def dimension_input(self):
        return _xmm.TrainingSet_dimension_input(self)

    def set_dimension(self, dimension):
        return _xmm.TrainingSet_set_dimension(self, dimension)

    def set_dimension_input(self, dimension_input):
        return _xmm.TrainingSet_set_dimension_input(self, dimension_input)

    def __eq__(self, src):
        return _xmm.TrainingSet___eq__(self, src)

    def __ne__(self, src):
        return _xmm.TrainingSet___ne__(self, src)

    def begin(self):
        return _xmm.TrainingSet_begin(self)

    def end(self):
        return _xmm.TrainingSet_end(self)

    def cbegin(self):
        return _xmm.TrainingSet_cbegin(self)

    def cend(self):
        return _xmm.TrainingSet_cend(self)

    def __call__(self, n):
        return _xmm.TrainingSet___call__(self, n)

    def connect(self, *args):
        return _xmm.TrainingSet_connect(self, *args)

    def recordPhrase(self, phraseIndex, observation):
        return _xmm.TrainingSet_recordPhrase(self, phraseIndex, observation)

    def recordPhrase_input(self, phraseIndex, observation):
        return _xmm.TrainingSet_recordPhrase_input(self, phraseIndex, observation)

    def recordPhrase_output(self, phraseIndex, observation):
        return _xmm.TrainingSet_recordPhrase_output(self, phraseIndex, observation)

    def resetPhrase(self, phraseIndex):
        return _xmm.TrainingSet_resetPhrase(self, phraseIndex)

    def deletePhrase(self, phraseIndex):
        return _xmm.TrainingSet_deletePhrase(self, phraseIndex)

    def deletePhrasesOfClass(self, label):
        return _xmm.TrainingSet_deletePhrasesOfClass(self, label)

    def deleteEmptyPhrases(self):
        return _xmm.TrainingSet_deleteEmptyPhrases(self)

    def clear(self):
        return _xmm.TrainingSet_clear(self)

    def setDefaultLabel(self, defLabel):
        return _xmm.TrainingSet_setDefaultLabel(self, defLabel)

    def setPhraseLabelToDefault(self, phraseIndex):
        return _xmm.TrainingSet_setPhraseLabelToDefault(self, phraseIndex)

    def setPhraseLabel(self, phraseIndex, label):
        return _xmm.TrainingSet_setPhraseLabel(self, phraseIndex, label)

    def getPhraseLabel(self, phraseIndex):
        return _xmm.TrainingSet_getPhraseLabel(self, phraseIndex)

    def getSubTrainingSetForClass(self, label):
        return _xmm.TrainingSet_getSubTrainingSetForClass(self, label)

    def updateSubTrainingSets(self):
        return _xmm.TrainingSet_updateSubTrainingSets(self)

    def mean(self):
        return _xmm.TrainingSet_mean(self)

    def variance(self):
        return _xmm.TrainingSet_variance(self)

    def to_json(self):
        return _xmm.TrainingSet_to_json(self)

    def from_json(self, root):
        return _xmm.TrainingSet_from_json(self, root)
    __swig_setmethods__["phrases"] = _xmm.TrainingSet_phrases_set
    __swig_getmethods__["phrases"] = _xmm.TrainingSet_phrases_get
    if _newclass:
        phrases = _swig_property(_xmm.TrainingSet_phrases_get, _xmm.TrainingSet_phrases_set)
    __swig_setmethods__["phraseLabels"] = _xmm.TrainingSet_phraseLabels_set
    __swig_getmethods__["phraseLabels"] = _xmm.TrainingSet_phraseLabels_get
    if _newclass:
        phraseLabels = _swig_property(_xmm.TrainingSet_phraseLabels_get, _xmm.TrainingSet_phraseLabels_set)
    __swig_setmethods__["allLabels"] = _xmm.TrainingSet_allLabels_set
    __swig_getmethods__["allLabels"] = _xmm.TrainingSet_allLabels_get
    if _newclass:
        allLabels = _swig_property(_xmm.TrainingSet_allLabels_get, _xmm.TrainingSet_allLabels_set)
TrainingSet_swigregister = _xmm.TrainingSet_swigregister
TrainingSet_swigregister(TrainingSet)


_xmm.TRAINING_RUN_swigconstant(_xmm)
TRAINING_RUN = _xmm.TRAINING_RUN

_xmm.TRAINING_DONE_swigconstant(_xmm)
TRAINING_DONE = _xmm.TRAINING_DONE

_xmm.TRAINING_ERROR_swigconstant(_xmm)
TRAINING_ERROR = _xmm.TRAINING_ERROR

_xmm.TRAINING_ABORT_swigconstant(_xmm)
TRAINING_ABORT = _xmm.TRAINING_ABORT
class EMStopCriterion(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EMStopCriterion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EMStopCriterion, name)
    __repr__ = _swig_repr
    __swig_setmethods__["minSteps"] = _xmm.EMStopCriterion_minSteps_set
    __swig_getmethods__["minSteps"] = _xmm.EMStopCriterion_minSteps_get
    if _newclass:
        minSteps = _swig_property(_xmm.EMStopCriterion_minSteps_get, _xmm.EMStopCriterion_minSteps_set)
    __swig_setmethods__["maxSteps"] = _xmm.EMStopCriterion_maxSteps_set
    __swig_getmethods__["maxSteps"] = _xmm.EMStopCriterion_maxSteps_get
    if _newclass:
        maxSteps = _swig_property(_xmm.EMStopCriterion_maxSteps_get, _xmm.EMStopCriterion_maxSteps_set)
    __swig_setmethods__["percentChg"] = _xmm.EMStopCriterion_percentChg_set
    __swig_getmethods__["percentChg"] = _xmm.EMStopCriterion_percentChg_get
    if _newclass:
        percentChg = _swig_property(_xmm.EMStopCriterion_percentChg_get, _xmm.EMStopCriterion_percentChg_set)

    def __init__(self):
        this = _xmm.new_EMStopCriterion()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_EMStopCriterion
    __del__ = lambda self: None
EMStopCriterion_swigregister = _xmm.EMStopCriterion_swigregister
EMStopCriterion_swigregister(EMStopCriterion)
EM_MODEL_DEFAULT_EMSTOP_MINSTEPS = cvar.EM_MODEL_DEFAULT_EMSTOP_MINSTEPS
EM_MODEL_DEFAULT_EMSTOP_MAXSTEPS = cvar.EM_MODEL_DEFAULT_EMSTOP_MAXSTEPS
EM_MODEL_DEFAULT_EMSTOP_PERCENT_CHG = cvar.EM_MODEL_DEFAULT_EMSTOP_PERCENT_CHG
EM_MODEL_DEFAULT_LIKELIHOOD_WINDOW = cvar.EM_MODEL_DEFAULT_LIKELIHOOD_WINDOW
EM_MODEL_DEFAULT_EMSTOP_ABSOLUTEMAXSTEPS = cvar.EM_MODEL_DEFAULT_EMSTOP_ABSOLUTEMAXSTEPS

class ProbabilisticModel(Listener, Writable):
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProbabilisticModel, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProbabilisticModel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_ProbabilisticModel
    __del__ = lambda self: None

    def is_training(self):
        return _xmm.ProbabilisticModel_is_training(self)

    def set_trainingSet(self, trainingSet):
        return _xmm.ProbabilisticModel_set_trainingSet(self, trainingSet)

    def dimension(self):
        return _xmm.ProbabilisticModel_dimension(self)

    def dimension_input(self):
        return _xmm.ProbabilisticModel_dimension_input(self)

    def get_likelihoodwindow(self):
        return _xmm.ProbabilisticModel_get_likelihoodwindow(self)

    def set_likelihoodwindow(self, likelihoodwindow):
        return _xmm.ProbabilisticModel_set_likelihoodwindow(self, likelihoodwindow)

    def train(self):
        return _xmm.ProbabilisticModel_train(self)

    def set_trainingCallback(self, callback, extradata):
        return _xmm.ProbabilisticModel_set_trainingCallback(self, callback, extradata)
    __swig_getmethods__["train_func"] = lambda x: _xmm.ProbabilisticModel_train_func
    if _newclass:
        train_func = staticmethod(_xmm.ProbabilisticModel_train_func)

    def performance_init(self):
        return _xmm.ProbabilisticModel_performance_init(self)

    def performance_update(self, observation):
        return _xmm.ProbabilisticModel_performance_update(self, observation)

    def to_json(self):
        return _xmm.ProbabilisticModel_to_json(self)

    def from_json(self, root):
        return _xmm.ProbabilisticModel_from_json(self, root)
    __swig_setmethods__["trainingSet"] = _xmm.ProbabilisticModel_trainingSet_set
    __swig_getmethods__["trainingSet"] = _xmm.ProbabilisticModel_trainingSet_get
    if _newclass:
        trainingSet = _swig_property(_xmm.ProbabilisticModel_trainingSet_get, _xmm.ProbabilisticModel_trainingSet_set)
    __swig_setmethods__["trained"] = _xmm.ProbabilisticModel_trained_set
    __swig_getmethods__["trained"] = _xmm.ProbabilisticModel_trained_get
    if _newclass:
        trained = _swig_property(_xmm.ProbabilisticModel_trained_get, _xmm.ProbabilisticModel_trained_set)
    __swig_setmethods__["stopcriterion"] = _xmm.ProbabilisticModel_stopcriterion_set
    __swig_getmethods__["stopcriterion"] = _xmm.ProbabilisticModel_stopcriterion_get
    if _newclass:
        stopcriterion = _swig_property(_xmm.ProbabilisticModel_stopcriterion_get, _xmm.ProbabilisticModel_stopcriterion_set)
    __swig_setmethods__["trainingProgression"] = _xmm.ProbabilisticModel_trainingProgression_set
    __swig_getmethods__["trainingProgression"] = _xmm.ProbabilisticModel_trainingProgression_get
    if _newclass:
        trainingProgression = _swig_property(_xmm.ProbabilisticModel_trainingProgression_get, _xmm.ProbabilisticModel_trainingProgression_set)
    __swig_setmethods__["results_instant_likelihood"] = _xmm.ProbabilisticModel_results_instant_likelihood_set
    __swig_getmethods__["results_instant_likelihood"] = _xmm.ProbabilisticModel_results_instant_likelihood_get
    if _newclass:
        results_instant_likelihood = _swig_property(_xmm.ProbabilisticModel_results_instant_likelihood_get, _xmm.ProbabilisticModel_results_instant_likelihood_set)
    __swig_setmethods__["results_log_likelihood"] = _xmm.ProbabilisticModel_results_log_likelihood_set
    __swig_getmethods__["results_log_likelihood"] = _xmm.ProbabilisticModel_results_log_likelihood_get
    if _newclass:
        results_log_likelihood = _swig_property(_xmm.ProbabilisticModel_results_log_likelihood_get, _xmm.ProbabilisticModel_results_log_likelihood_set)
    __swig_setmethods__["results_predicted_output"] = _xmm.ProbabilisticModel_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm.ProbabilisticModel_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm.ProbabilisticModel_results_predicted_output_get, _xmm.ProbabilisticModel_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm.ProbabilisticModel_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm.ProbabilisticModel_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm.ProbabilisticModel_results_output_variance_get, _xmm.ProbabilisticModel_results_output_variance_set)
    __swig_setmethods__["trainingLogLikelihood"] = _xmm.ProbabilisticModel_trainingLogLikelihood_set
    __swig_getmethods__["trainingLogLikelihood"] = _xmm.ProbabilisticModel_trainingLogLikelihood_get
    if _newclass:
        trainingLogLikelihood = _swig_property(_xmm.ProbabilisticModel_trainingLogLikelihood_get, _xmm.ProbabilisticModel_trainingLogLikelihood_set)
    __swig_setmethods__["trainingNbIterations"] = _xmm.ProbabilisticModel_trainingNbIterations_set
    __swig_getmethods__["trainingNbIterations"] = _xmm.ProbabilisticModel_trainingNbIterations_get
    if _newclass:
        trainingNbIterations = _swig_property(_xmm.ProbabilisticModel_trainingNbIterations_get, _xmm.ProbabilisticModel_trainingNbIterations_set)
ProbabilisticModel_swigregister = _xmm.ProbabilisticModel_swigregister
ProbabilisticModel_swigregister(ProbabilisticModel)

def ProbabilisticModel_train_func(context):
    return _xmm.ProbabilisticModel_train_func(context)
ProbabilisticModel_train_func = _xmm.ProbabilisticModel_train_func

class t_ellipse(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, t_ellipse, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, t_ellipse, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _xmm.t_ellipse_x_set
    __swig_getmethods__["x"] = _xmm.t_ellipse_x_get
    if _newclass:
        x = _swig_property(_xmm.t_ellipse_x_get, _xmm.t_ellipse_x_set)
    __swig_setmethods__["y"] = _xmm.t_ellipse_y_set
    __swig_getmethods__["y"] = _xmm.t_ellipse_y_get
    if _newclass:
        y = _swig_property(_xmm.t_ellipse_y_get, _xmm.t_ellipse_y_set)
    __swig_setmethods__["width"] = _xmm.t_ellipse_width_set
    __swig_getmethods__["width"] = _xmm.t_ellipse_width_get
    if _newclass:
        width = _swig_property(_xmm.t_ellipse_width_get, _xmm.t_ellipse_width_set)
    __swig_setmethods__["height"] = _xmm.t_ellipse_height_set
    __swig_getmethods__["height"] = _xmm.t_ellipse_height_get
    if _newclass:
        height = _swig_property(_xmm.t_ellipse_height_get, _xmm.t_ellipse_height_set)
    __swig_setmethods__["angle"] = _xmm.t_ellipse_angle_set
    __swig_getmethods__["angle"] = _xmm.t_ellipse_angle_get
    if _newclass:
        angle = _swig_property(_xmm.t_ellipse_angle_get, _xmm.t_ellipse_angle_set)

    def __init__(self):
        this = _xmm.new_t_ellipse()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_t_ellipse
    __del__ = lambda self: None
t_ellipse_swigregister = _xmm.t_ellipse_swigregister
t_ellipse_swigregister(t_ellipse)
GAUSSIAN_DEFAULT_VARIANCE_OFFSET_RELATIVE = cvar.GAUSSIAN_DEFAULT_VARIANCE_OFFSET_RELATIVE
GAUSSIAN_DEFAULT_VARIANCE_OFFSET_ABSOLUTE = cvar.GAUSSIAN_DEFAULT_VARIANCE_OFFSET_ABSOLUTE
EPSILON_GAUSSIAN = cvar.EPSILON_GAUSSIAN

class GaussianDistribution(Writable):
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianDistribution, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _xmm.new_GaussianDistribution(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def _copy(self, dst, src):
        return _xmm.GaussianDistribution__copy(self, dst, src)
    __swig_destroy__ = _xmm.delete_GaussianDistribution
    __del__ = lambda self: None

    def dimension(self):
        return _xmm.GaussianDistribution_dimension(self)

    def set_dimension(self, dimension):
        return _xmm.GaussianDistribution_set_dimension(self, dimension)

    def dimension_input(self):
        return _xmm.GaussianDistribution_dimension_input(self)

    def set_dimension_input(self, dimension_input):
        return _xmm.GaussianDistribution_set_dimension_input(self, dimension_input)

    def likelihood(self, observation):
        return _xmm.GaussianDistribution_likelihood(self, observation)

    def likelihood_input(self, observation_input):
        return _xmm.GaussianDistribution_likelihood_input(self, observation_input)

    def likelihood_bimodal(self, observation_input, observation_output):
        return _xmm.GaussianDistribution_likelihood_bimodal(self, observation_input, observation_output)

    def regression(self, observation_input, predicted_output):
        return _xmm.GaussianDistribution_regression(self, observation_input, predicted_output)

    def to_json(self):
        return _xmm.GaussianDistribution_to_json(self)

    def from_json(self, root):
        return _xmm.GaussianDistribution_from_json(self, root)

    def allocate(self):
        return _xmm.GaussianDistribution_allocate(self)

    def addOffset(self):
        return _xmm.GaussianDistribution_addOffset(self)

    def updateInverseCovariance(self):
        return _xmm.GaussianDistribution_updateInverseCovariance(self)

    def updateOutputVariances(self):
        return _xmm.GaussianDistribution_updateOutputVariances(self)

    def ellipse(self, dimension1, dimension2):
        return _xmm.GaussianDistribution_ellipse(self, dimension1, dimension2)
    __swig_setmethods__["mean"] = _xmm.GaussianDistribution_mean_set
    __swig_getmethods__["mean"] = _xmm.GaussianDistribution_mean_get
    if _newclass:
        mean = _swig_property(_xmm.GaussianDistribution_mean_get, _xmm.GaussianDistribution_mean_set)
    __swig_setmethods__["covariance"] = _xmm.GaussianDistribution_covariance_set
    __swig_getmethods__["covariance"] = _xmm.GaussianDistribution_covariance_get
    if _newclass:
        covariance = _swig_property(_xmm.GaussianDistribution_covariance_get, _xmm.GaussianDistribution_covariance_set)
    __swig_setmethods__["offset_relative"] = _xmm.GaussianDistribution_offset_relative_set
    __swig_getmethods__["offset_relative"] = _xmm.GaussianDistribution_offset_relative_get
    if _newclass:
        offset_relative = _swig_property(_xmm.GaussianDistribution_offset_relative_get, _xmm.GaussianDistribution_offset_relative_set)
    __swig_setmethods__["offset_absolute"] = _xmm.GaussianDistribution_offset_absolute_set
    __swig_getmethods__["offset_absolute"] = _xmm.GaussianDistribution_offset_absolute_get
    if _newclass:
        offset_absolute = _swig_property(_xmm.GaussianDistribution_offset_absolute_get, _xmm.GaussianDistribution_offset_absolute_set)
    __swig_setmethods__["scale"] = _xmm.GaussianDistribution_scale_set
    __swig_getmethods__["scale"] = _xmm.GaussianDistribution_scale_get
    if _newclass:
        scale = _swig_property(_xmm.GaussianDistribution_scale_get, _xmm.GaussianDistribution_scale_set)
    __swig_setmethods__["weight_regression"] = _xmm.GaussianDistribution_weight_regression_set
    __swig_getmethods__["weight_regression"] = _xmm.GaussianDistribution_weight_regression_get
    if _newclass:
        weight_regression = _swig_property(_xmm.GaussianDistribution_weight_regression_get, _xmm.GaussianDistribution_weight_regression_set)
    __swig_setmethods__["output_variance"] = _xmm.GaussianDistribution_output_variance_set
    __swig_getmethods__["output_variance"] = _xmm.GaussianDistribution_output_variance_get
    if _newclass:
        output_variance = _swig_property(_xmm.GaussianDistribution_output_variance_get, _xmm.GaussianDistribution_output_variance_set)
GaussianDistribution_swigregister = _xmm.GaussianDistribution_swigregister
GaussianDistribution_swigregister(GaussianDistribution)

class KMeans(Listener, Writable):
    """C++ includes: kmeans.h """
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeans, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeans, name)
    __repr__ = _swig_repr
    RANDOM = _xmm.KMeans_RANDOM
    BIASED = _xmm.KMeans_BIASED

    def __init__(self, *args):
        """
        KMeans::KMeans(KMeans const
        &src)

        Copy Constructor.

        Parameters:
        -----------

        src:  Source Model 
        """
        this = _xmm.new_KMeans(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_KMeans
    __del__ = lambda self: None

    def is_training(self):
        """
        bool
        KMeans::is_training() const

        Checks if the model is training.

        true if the model is training 
        """
        return _xmm.KMeans_is_training(self)


    def set_trainingSet(self, trainingSet):
        """
        void
        KMeans::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the dimensions of the model

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.KMeans_set_trainingSet(self, trainingSet)


    def dimension(self):
        """
        unsigned int
        KMeans::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm.KMeans_dimension(self)


    def get_nbClusters(self):
        """
        unsigned int
        KMeans::get_nbClusters()

        Get Number of Clusters.

        Number of Clusters 
        """
        return _xmm.KMeans_get_nbClusters(self)


    def set_nbClusters(self, nbClusters):
        """
        void
        KMeans::set_nbClusters(unsigned int nbClusters)

        Set Number of Clusters.

        Parameters:
        -----------

        nbClusters:  Number of Clusters 
        """
        return _xmm.KMeans_set_nbClusters(self, nbClusters)


    def get_training_maxIterations(self):
        """
        unsigned
        int KMeans::get_training_maxIterations() const

        Get Maximum number of training iterations.

        Maximum number of training iterations 
        """
        return _xmm.KMeans_get_training_maxIterations(self)


    def set_training_maxIterations(self, maxIterations):
        """
        void
        KMeans::set_training_maxIterations(unsigned int maxIterations)

        Set Maximum number of training iterations.

        Parameters:
        -----------

        maxIterations:  Maximum number of training iterations 
        """
        return _xmm.KMeans_set_training_maxIterations(self, maxIterations)


    def get_training_relativeDistanceThreshold(self):
        """
        unsigned int KMeans::get_training_relativeDistanceThreshold() const

        Get relative distance Threshold for training.

        relative distance Threshold for training 
        """
        return _xmm.KMeans_get_training_relativeDistanceThreshold(self)


    def set_training_relativeDistanceThreshold(self, threshold):
        """
        void KMeans::set_training_relativeDistanceThreshold(float threshold)

        Set relative distance Threshold for training.

        Parameters:
        -----------

        threshold:  relative distance Threshold for training 
        """
        return _xmm.KMeans_set_training_relativeDistanceThreshold(self, threshold)


    def train(self):
        """
        void KMeans::train()

        Main training method. 
        """
        return _xmm.KMeans_train(self)


    def randomizeClusters(self):
        """
        void
        KMeans::randomizeClusters()

        randomzie Cluster Centers (normalized width data variance) of the
        first phrase of the training set 
        """
        return _xmm.KMeans_randomizeClusters(self)


    def set_trainingCallback(self, callback, extradata):
        """
        void
        KMeans::set_trainingCallback(void(*callback)(void *srcModel,
        CALLBACK_FLAG state, void *extradata), void *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm.KMeans_set_trainingCallback(self, callback, extradata)


    def train_func(context):
        """
        void *
        KMeans::train_func(void *context)

        Function pointer for parallel training.

        Parameters:
        -----------

        context:  pointer to the object to train 
        """
        return _xmm.KMeans_train_func(context)

    if _newclass:
        train_func = staticmethod(train_func)
    __swig_getmethods__["train_func"] = lambda x: train_func

    def performance_init(self):
        """
        void
        KMeans::performance_init()

        Initialize the 'Performance' phase: prepare model for performance. 
        """
        return _xmm.KMeans_performance_init(self)


    def performance_update(self, observation):
        """
        void
        KMeans::performance_update(vector< float > const &observation)

        Main Performance function: updates the predictions of the model given
        a new observation.

        Parameters:
        -----------

        observation:  observation vector (must be of size 'dimension') 
        """
        return _xmm.KMeans_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode KMeans::to_json()
        const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.KMeans_to_json(self)


    def from_json(self, root):
        """
        void
        KMeans::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.KMeans_from_json(self, root)

    __swig_setmethods__["trainingSet"] = _xmm.KMeans_trainingSet_set
    __swig_getmethods__["trainingSet"] = _xmm.KMeans_trainingSet_get
    if _newclass:
        trainingSet = _swig_property(_xmm.KMeans_trainingSet_get, _xmm.KMeans_trainingSet_set)
    __swig_setmethods__["centers"] = _xmm.KMeans_centers_set
    __swig_getmethods__["centers"] = _xmm.KMeans_centers_get
    if _newclass:
        centers = _swig_property(_xmm.KMeans_centers_get, _xmm.KMeans_centers_set)
    __swig_setmethods__["trainingNbIterations"] = _xmm.KMeans_trainingNbIterations_set
    __swig_getmethods__["trainingNbIterations"] = _xmm.KMeans_trainingNbIterations_get
    if _newclass:
        trainingNbIterations = _swig_property(_xmm.KMeans_trainingNbIterations_get, _xmm.KMeans_trainingNbIterations_set)
    __swig_setmethods__["results_distances"] = _xmm.KMeans_results_distances_set
    __swig_getmethods__["results_distances"] = _xmm.KMeans_results_distances_get
    if _newclass:
        results_distances = _swig_property(_xmm.KMeans_results_distances_get, _xmm.KMeans_results_distances_set)
    __swig_setmethods__["results_likeliest"] = _xmm.KMeans_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm.KMeans_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm.KMeans_results_likeliest_get, _xmm.KMeans_results_likeliest_set)
    __swig_setmethods__["trainingInitType"] = _xmm.KMeans_trainingInitType_set
    __swig_getmethods__["trainingInitType"] = _xmm.KMeans_trainingInitType_get
    if _newclass:
        trainingInitType = _swig_property(_xmm.KMeans_trainingInitType_get, _xmm.KMeans_trainingInitType_set)
KMeans_swigregister = _xmm.KMeans_swigregister
KMeans_swigregister(KMeans)
KMEANS_DEFAULT_MAX_ITERATIONS = cvar.KMEANS_DEFAULT_MAX_ITERATIONS
KMEANS_DEFAULT_RELATIVE_VARIATION_THRESHOLD = cvar.KMEANS_DEFAULT_RELATIVE_VARIATION_THRESHOLD

def KMeans_train_func(context):
    """
    void *
    KMeans::train_func(void *context)

    Function pointer for parallel training.

    Parameters:
    -----------

    context:  pointer to the object to train 
    """
    return _xmm.KMeans_train_func(context)

class GMM(ProbabilisticModel):
    """
    Gaussian Mixture Models.

    Multivariate Gaussian Mixture Model. Supports Bimodal data and
    Gaussian Mixture Regression. Can be either autonomous or a state of a
    HMM: defines observation probabilities for each state.

    C++ includes: gmm.h 
    """
    __swig_setmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        GMM::GMM(GMM const &src)

        Copy constructor.

        Parameters:
        -----------

        src:  Source GMM 
        """
        this = _xmm.new_GMM(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_GMM
    __del__ = lambda self: None

    def get_nbMixtureComponents(self):
        """
        int
        GMM::get_nbMixtureComponents() const

        Get the number of Gaussian mixture Components.

        number of Gaussian mixture components 
        """
        return _xmm.GMM_get_nbMixtureComponents(self)


    def get_varianceOffset_relative(self):
        """
        double
        GMM::get_varianceOffset_relative() const

        Get Offset added to covariance matrices for convergence.

        Offset added to covariance matrices for convergence (relative to data
        variance) 
        """
        return _xmm.GMM_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double
        GMM::get_varianceOffset_absolute() const

        Get Offset added to covariance matrices for convergence.

        Offset added to covariance matrices for convergence (minimum value) 
        """
        return _xmm.GMM_get_varianceOffset_absolute(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        GMM::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of mixture components of the model.

        WARNING:  sets the model to be untrained.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian Mixture Components

        Exceptions:
        -----------

        invalid_argument:  if nbMixtureComponents is <= 0 
        """
        return _xmm.GMM_set_nbMixtureComponents(self, nbMixtureComponents)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        GMM::set_varianceOffset(double varianceOffset_relative, double
        varianceOffset_absolute)

        Set the offset to add to the covariance matrices.

        Parameters:
        -----------

        varianceOffset_relative:  offset to add to the diagonal of covariance
        matrices (relative to data variance)

        varianceOffset_absolute:  offset to add to the diagonal of covariance
        matrices (minimum value)

        Exceptions:
        -----------

        invalid_argument:  if the covariance offset is <= 0 
        """
        return _xmm.GMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        GMM::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.GMM_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        GMM::set_weight_regression(double weight_regression)

        Get Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.GMM_set_weight_regression(self, weight_regression)


    def performance_init(self):
        """
        void
        GMM::performance_init()

        Initialize performance mode. 
        """
        return _xmm.GMM_performance_init(self)


    def performance_update(self, observation):
        """
        double
        GMM::performance_update(vector< float > const &observation)

        Main Play function: performs recognition (unimodal mode) or regression
        (bimodal mode)

        The predicted output is stored in the observation vector in bimodal
        mode

        Parameters:
        -----------

        observation:  observation (must allocated to size 'dimension')

        instantaneous likelihood 
        """
        return _xmm.GMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode GMM::to_json() const

        Write to JSON Node.

        JSON Node containing model information and parameters 
        """
        return _xmm.GMM_to_json(self)


    def from_json(self, root):
        """
        void GMM::from_json(JSONNode
        root)

        Read from JSON Node.

        allocate model parameters and updates inverse Covariances

        Parameters:
        -----------

        root:  JSON Node containing model information and parameters

        Exceptions:
        -----------

        JSONException if the JSONNode has a wrong format 
        """
        return _xmm.GMM_from_json(self, root)

    __swig_setmethods__["components"] = _xmm.GMM_components_set
    __swig_getmethods__["components"] = _xmm.GMM_components_get
    if _newclass:
        components = _swig_property(_xmm.GMM_components_get, _xmm.GMM_components_set)
    __swig_setmethods__["mixtureCoeffs"] = _xmm.GMM_mixtureCoeffs_set
    __swig_getmethods__["mixtureCoeffs"] = _xmm.GMM_mixtureCoeffs_get
    if _newclass:
        mixtureCoeffs = _swig_property(_xmm.GMM_mixtureCoeffs_get, _xmm.GMM_mixtureCoeffs_set)
    __swig_setmethods__["beta"] = _xmm.GMM_beta_set
    __swig_getmethods__["beta"] = _xmm.GMM_beta_get
    if _newclass:
        beta = _swig_property(_xmm.GMM_beta_get, _xmm.GMM_beta_set)
GMM_swigregister = _xmm.GMM_swigregister
GMM_swigregister(GMM)
GMM_DEFAULT_NB_MIXTURE_COMPONENTS = cvar.GMM_DEFAULT_NB_MIXTURE_COMPONENTS


_xmm.ERGODIC_swigconstant(_xmm)
ERGODIC = _xmm.ERGODIC

_xmm.LEFT_RIGHT_swigconstant(_xmm)
LEFT_RIGHT = _xmm.LEFT_RIGHT

_xmm.FULL_swigconstant(_xmm)
FULL = _xmm.FULL

_xmm.WINDOWED_swigconstant(_xmm)
WINDOWED = _xmm.WINDOWED

_xmm.LIKELIEST_swigconstant(_xmm)
LIKELIEST = _xmm.LIKELIEST
class HMM(ProbabilisticModel):
    """
    Hidden Markov Model.

    Support Hierarchical Model: if built with the flag 'HIERARCHICAL', the
    model includes exit transition probabilities. The model can be eith
    unimodal, or Multimodal when constructed with the flag 'BIMODAL'.

    C++ includes: hmm.h 
    """
    __swig_setmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        HMM::HMM(HMM const &src)

        Copy constructor.

        Parameters:
        -----------

        src:  Source Model 
        """
        this = _xmm.new_HMM(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_HMM
    __del__ = lambda self: None

    def set_trainingSet(self, trainingSet):
        """
        void
        HMM::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the training sets of each GMM

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.HMM_set_trainingSet(self, trainingSet)


    def get_nbStates(self):
        """
        int HMM::get_nbStates()
        const

        Get the Number of hidden states of the model.

        number of hidden states 
        """
        return _xmm.HMM_get_nbStates(self)


    def set_nbStates(self, nbStates):
        """
        void HMM::set_nbStates(int
        nbStates)

        Set the number of hidden states of the model.

        sets the mode to be untrained

        Parameters:
        -----------

        nbStates:  number of hidden states

        Exceptions:
        -----------

        invalid_argument:  if the number of states is <= 0 
        """
        return _xmm.HMM_set_nbStates(self, nbStates)


    def get_nbMixtureComponents(self):
        """
        int
        HMM::get_nbMixtureComponents() const

        Get the number of Gaussian mixture components of the observation
        probability distribution.

        number of Gaussian mixture components 
        """
        return _xmm.HMM_get_nbMixtureComponents(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        HMM::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of Gaussian mixture components of the observation
        probability distribution.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian mixture components

        Exceptions:
        -----------

        invalid_argument:  if the number of Gaussian mixture components is <=
        0 
        """
        return _xmm.HMM_set_nbMixtureComponents(self, nbMixtureComponents)


    def get_varianceOffset_relative(self):
        """
        double
        HMM::get_varianceOffset_relative() const

        Get the offset added to the diagonal of covariance matrices for
        convergence.

        offset added to the diagonal of covariance matrices (relative to data
        variance) 
        """
        return _xmm.HMM_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double
        HMM::get_varianceOffset_absolute() const

        Get the offset added to the diagonal of covariance matrices for
        convergence.

        offset added to the diagonal of covariance matrices (minimum value) 
        """
        return _xmm.HMM_get_varianceOffset_absolute(self)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        HMM::set_varianceOffset(double varianceOffset_relative, double
        varianceOffset_absolute)

        Get the offset added to the diagonal of covariance matrices for
        convergence.

        Parameters:
        -----------

        varianceOffset_relative:  offset added to the diagonal of covariances
        matrices (relative to data variance)

        varianceOffset_absolute:  offset added to the diagonal of covariances
        matrices (minimum value) 
        """
        return _xmm.HMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        HMM::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.HMM_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        HMM::set_weight_regression(double weight_regression)

        Set Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.HMM_set_weight_regression(self, weight_regression)


    def get_regression_estimator(self):
        """
        REGRESSION_ESTIMATOR HMM::get_regression_estimator() const

        Get the regression estimator type.

        regression estimator type

        See:   REGRESSION_ESTIMATOR 
        """
        return _xmm.HMM_get_regression_estimator(self)


    def set_regression_estimator(self, regression_estimator):
        """
        void
        HMM::set_regression_estimator(REGRESSION_ESTIMATOR
        regression_estimator)

        Set the regression estimator type.

        Parameters:
        -----------

        regression_estimator:  type of estimator

        See:   REGRESSION_ESTIMATOR 
        """
        return _xmm.HMM_set_regression_estimator(self, regression_estimator)


    def get_transitionMode(self):
        """
        string
        HMM::get_transitionMode() const

        get transition mode of the hidden Markov Chain

        string corresponding to the transition mode (left-right / ergodic) 
        """
        return _xmm.HMM_get_transitionMode(self)


    def set_transitionMode(self, transMode_str):
        """
        void
        HMM::set_transitionMode(string transMode_str)

        set transition mode of the hidden Markov Chain

        Parameters:
        -----------

        transMode_str:  string keyword corresponding to the transition mode
        ("left-right" / "ergodic")

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "left-right" or
        "ergodic" 
        """
        return _xmm.HMM_set_transitionMode(self, transMode_str)


    def addExitPoint(self, stateIndex, proba):
        """
        void HMM::addExitPoint(int
        stateIndex, float proba)

        Set the exit probability of a specific state.

        this method is only active in 'HIERARCHICAL' mode. The probability

        Parameters:
        -----------

        stateIndex:  index of the state to add the exit point

        proba:  probability to exit the gesture from this state

        Exceptions:
        -----------

        runtime_error:  if the model is not hierarchical

        out_of_range:  if the state index is out of bounds 
        """
        return _xmm.HMM_addExitPoint(self, stateIndex, proba)


    def performance_init(self):
        """
        void
        HMM::performance_init()

        Initialize the 'Performance' phase. 
        """
        return _xmm.HMM_performance_init(self)


    def performance_update(self, observation):
        """
        double
        HMM::performance_update(vector< float > const &observation)

        Main Play function: performs recognition (unimodal mode) or regression
        (bimodal mode)

        The predicted output is stored in the observation vector in bimodal
        mode

        Parameters:
        -----------

        observation:  pointer to current observation vector. Must be of size
        'dimension' (input + output dimension).

        likelihood computed on the gesture modality by a forward algorithm 
        """
        return _xmm.HMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode HMM::to_json() const

        Write to JSON Node.

        JSON Node containing model information and parameters 
        """
        return _xmm.HMM_to_json(self)


    def from_json(self, root):
        """
        void HMM::from_json(JSONNode
        root)

        Read from JSON Node.

        allocate model parameters and updates inverse Covariances

        Parameters:
        -----------

        root:  JSON Node containing model information and parameters

        Exceptions:
        -----------

        JSONException if the JSONNode has a wrong format 
        """
        return _xmm.HMM_from_json(self, root)

    __swig_setmethods__["results_progress"] = _xmm.HMM_results_progress_set
    __swig_getmethods__["results_progress"] = _xmm.HMM_results_progress_get
    if _newclass:
        results_progress = _swig_property(_xmm.HMM_results_progress_get, _xmm.HMM_results_progress_set)
    __swig_setmethods__["results_exit_likelihood"] = _xmm.HMM_results_exit_likelihood_set
    __swig_getmethods__["results_exit_likelihood"] = _xmm.HMM_results_exit_likelihood_get
    if _newclass:
        results_exit_likelihood = _swig_property(_xmm.HMM_results_exit_likelihood_get, _xmm.HMM_results_exit_likelihood_set)
    __swig_setmethods__["results_exit_ratio"] = _xmm.HMM_results_exit_ratio_set
    __swig_getmethods__["results_exit_ratio"] = _xmm.HMM_results_exit_ratio_get
    if _newclass:
        results_exit_ratio = _swig_property(_xmm.HMM_results_exit_ratio_get, _xmm.HMM_results_exit_ratio_set)
    __swig_setmethods__["results_likeliest_state"] = _xmm.HMM_results_likeliest_state_set
    __swig_getmethods__["results_likeliest_state"] = _xmm.HMM_results_likeliest_state_get
    if _newclass:
        results_likeliest_state = _swig_property(_xmm.HMM_results_likeliest_state_get, _xmm.HMM_results_likeliest_state_set)
    __swig_setmethods__["alpha"] = _xmm.HMM_alpha_set
    __swig_getmethods__["alpha"] = _xmm.HMM_alpha_get
    if _newclass:
        alpha = _swig_property(_xmm.HMM_alpha_get, _xmm.HMM_alpha_set)
    __swig_setmethods__["alpha_h"] = _xmm.HMM_alpha_h_set
    __swig_getmethods__["alpha_h"] = _xmm.HMM_alpha_h_get
    if _newclass:
        alpha_h = _swig_property(_xmm.HMM_alpha_h_get, _xmm.HMM_alpha_h_set)
    __swig_setmethods__["states_"] = _xmm.HMM_states__set
    __swig_getmethods__["states_"] = _xmm.HMM_states__get
    if _newclass:
        states_ = _swig_property(_xmm.HMM_states__get, _xmm.HMM_states__set)
HMM_swigregister = _xmm.HMM_swigregister
HMM_swigregister(HMM)
HMM_DEFAULT_NB_STATES = cvar.HMM_DEFAULT_NB_STATES
HMM_DEFAULT_ESTIMATEMEANS = cvar.HMM_DEFAULT_ESTIMATEMEANS
PLAY_EM_MAX_LOG_LIK_PERCENT_CHG = cvar.PLAY_EM_MAX_LOG_LIK_PERCENT_CHG
PLAY_EM_STEPS = cvar.PLAY_EM_STEPS
HMM_DEFAULT_EXITPROBABILITY_LAST_STATE = cvar.HMM_DEFAULT_EXITPROBABILITY_LAST_STATE
HMM_TRANSITION_REGULARIZATION = cvar.HMM_TRANSITION_REGULARIZATION

class _MODELGROUP_GMM(Listener, Writable):
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MODELGROUP_GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _MODELGROUP_GMM, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LIKELIEST = _xmm._MODELGROUP_GMM_LIKELIEST
    MIXTURE = _xmm._MODELGROUP_GMM_MIXTURE
    __swig_destroy__ = _xmm.delete__MODELGROUP_GMM
    __del__ = lambda self: None

    def is_training(self):
        return _xmm._MODELGROUP_GMM_is_training(self)

    def is_trained(self, *args):
        return _xmm._MODELGROUP_GMM_is_trained(self, *args)

    def size(self):
        return _xmm._MODELGROUP_GMM_size(self)

    def clear(self):
        return _xmm._MODELGROUP_GMM_clear(self)

    def remove(self, label):
        return _xmm._MODELGROUP_GMM_remove(self, label)

    def set_trainingSet(self, globalTrainingSet):
        return _xmm._MODELGROUP_GMM_set_trainingSet(self, globalTrainingSet)

    def dimension(self):
        return _xmm._MODELGROUP_GMM_dimension(self)

    def dimension_input(self):
        return _xmm._MODELGROUP_GMM_dimension_input(self)

    def set_performanceMode(self, performanceMode_str):
        return _xmm._MODELGROUP_GMM_set_performanceMode(self, performanceMode_str)

    def get_performanceMode(self):
        return _xmm._MODELGROUP_GMM_get_performanceMode(self)

    def get_EM_minSteps(self):
        return _xmm._MODELGROUP_GMM_get_EM_minSteps(self)

    def get_EM_maxSteps(self):
        return _xmm._MODELGROUP_GMM_get_EM_maxSteps(self)

    def get_EM_percentChange(self):
        return _xmm._MODELGROUP_GMM_get_EM_percentChange(self)

    def set_EM_minSteps(self, steps):
        return _xmm._MODELGROUP_GMM_set_EM_minSteps(self, steps)

    def set_EM_maxSteps(self, steps):
        return _xmm._MODELGROUP_GMM_set_EM_maxSteps(self, steps)

    def set_EM_percentChange(self, logLikPercentChg_):
        return _xmm._MODELGROUP_GMM_set_EM_percentChange(self, logLikPercentChg_)

    def get_likelihoodwindow(self):
        return _xmm._MODELGROUP_GMM_get_likelihoodwindow(self)

    def set_likelihoodwindow(self, likelihoodwindow):
        return _xmm._MODELGROUP_GMM_set_likelihoodwindow(self, likelihoodwindow)

    def train(self, *args):
        return _xmm._MODELGROUP_GMM_train(self, *args)

    def retrain(self):
        return _xmm._MODELGROUP_GMM_retrain(self)
    __swig_getmethods__["monitor_training"] = lambda x: _xmm._MODELGROUP_GMM_monitor_training
    if _newclass:
        monitor_training = staticmethod(_xmm._MODELGROUP_GMM_monitor_training)

    def set_trainingCallback(self, callback, extradata):
        return _xmm._MODELGROUP_GMM_set_trainingCallback(self, callback, extradata)

    def performance_init(self):
        return _xmm._MODELGROUP_GMM_performance_init(self)

    def update_likelihood_results(self):
        return _xmm._MODELGROUP_GMM_update_likelihood_results(self)
    __swig_setmethods__["models"] = _xmm._MODELGROUP_GMM_models_set
    __swig_getmethods__["models"] = _xmm._MODELGROUP_GMM_models_get
    if _newclass:
        models = _swig_property(_xmm._MODELGROUP_GMM_models_get, _xmm._MODELGROUP_GMM_models_set)
    __swig_setmethods__["globalTrainingSet"] = _xmm._MODELGROUP_GMM_globalTrainingSet_set
    __swig_getmethods__["globalTrainingSet"] = _xmm._MODELGROUP_GMM_globalTrainingSet_get
    if _newclass:
        globalTrainingSet = _swig_property(_xmm._MODELGROUP_GMM_globalTrainingSet_get, _xmm._MODELGROUP_GMM_globalTrainingSet_set)
    __swig_setmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_instant_likelihoods_set
    __swig_getmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_instant_likelihoods_get
    if _newclass:
        results_instant_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_instant_likelihoods_get, _xmm._MODELGROUP_GMM_results_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_set
    __swig_getmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_get
    if _newclass:
        results_normalized_instant_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_get, _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_likelihoods_set
    __swig_getmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_likelihoods_get
    if _newclass:
        results_normalized_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_normalized_likelihoods_get, _xmm._MODELGROUP_GMM_results_normalized_likelihoods_set)
    __swig_setmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_GMM_results_log_likelihoods_set
    __swig_getmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_GMM_results_log_likelihoods_get
    if _newclass:
        results_log_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_log_likelihoods_get, _xmm._MODELGROUP_GMM_results_log_likelihoods_set)
    __swig_setmethods__["results_likeliest"] = _xmm._MODELGROUP_GMM_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm._MODELGROUP_GMM_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm._MODELGROUP_GMM_results_likeliest_get, _xmm._MODELGROUP_GMM_results_likeliest_set)
    __swig_setmethods__["results_predicted_output"] = _xmm._MODELGROUP_GMM_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm._MODELGROUP_GMM_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm._MODELGROUP_GMM_results_predicted_output_get, _xmm._MODELGROUP_GMM_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm._MODELGROUP_GMM_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm._MODELGROUP_GMM_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm._MODELGROUP_GMM_results_output_variance_get, _xmm._MODELGROUP_GMM_results_output_variance_set)
_MODELGROUP_GMM_swigregister = _xmm._MODELGROUP_GMM_swigregister
_MODELGROUP_GMM_swigregister(_MODELGROUP_GMM)

def _MODELGROUP_GMM_monitor_training(model, state, extradata):
    return _xmm._MODELGROUP_GMM_monitor_training(model, state, extradata)
_MODELGROUP_GMM_monitor_training = _xmm._MODELGROUP_GMM_monitor_training

class _MODELGROUP_HMM(Listener, Writable):
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MODELGROUP_HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _MODELGROUP_HMM, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LIKELIEST = _xmm._MODELGROUP_HMM_LIKELIEST
    MIXTURE = _xmm._MODELGROUP_HMM_MIXTURE
    __swig_destroy__ = _xmm.delete__MODELGROUP_HMM
    __del__ = lambda self: None

    def is_training(self):
        return _xmm._MODELGROUP_HMM_is_training(self)

    def is_trained(self, *args):
        return _xmm._MODELGROUP_HMM_is_trained(self, *args)

    def size(self):
        return _xmm._MODELGROUP_HMM_size(self)

    def clear(self):
        return _xmm._MODELGROUP_HMM_clear(self)

    def remove(self, label):
        return _xmm._MODELGROUP_HMM_remove(self, label)

    def set_trainingSet(self, globalTrainingSet):
        return _xmm._MODELGROUP_HMM_set_trainingSet(self, globalTrainingSet)

    def dimension(self):
        return _xmm._MODELGROUP_HMM_dimension(self)

    def dimension_input(self):
        return _xmm._MODELGROUP_HMM_dimension_input(self)

    def set_performanceMode(self, performanceMode_str):
        return _xmm._MODELGROUP_HMM_set_performanceMode(self, performanceMode_str)

    def get_performanceMode(self):
        return _xmm._MODELGROUP_HMM_get_performanceMode(self)

    def get_EM_minSteps(self):
        return _xmm._MODELGROUP_HMM_get_EM_minSteps(self)

    def get_EM_maxSteps(self):
        return _xmm._MODELGROUP_HMM_get_EM_maxSteps(self)

    def get_EM_percentChange(self):
        return _xmm._MODELGROUP_HMM_get_EM_percentChange(self)

    def set_EM_minSteps(self, steps):
        return _xmm._MODELGROUP_HMM_set_EM_minSteps(self, steps)

    def set_EM_maxSteps(self, steps):
        return _xmm._MODELGROUP_HMM_set_EM_maxSteps(self, steps)

    def set_EM_percentChange(self, logLikPercentChg_):
        return _xmm._MODELGROUP_HMM_set_EM_percentChange(self, logLikPercentChg_)

    def get_likelihoodwindow(self):
        return _xmm._MODELGROUP_HMM_get_likelihoodwindow(self)

    def set_likelihoodwindow(self, likelihoodwindow):
        return _xmm._MODELGROUP_HMM_set_likelihoodwindow(self, likelihoodwindow)

    def train(self, *args):
        return _xmm._MODELGROUP_HMM_train(self, *args)

    def retrain(self):
        return _xmm._MODELGROUP_HMM_retrain(self)
    __swig_getmethods__["monitor_training"] = lambda x: _xmm._MODELGROUP_HMM_monitor_training
    if _newclass:
        monitor_training = staticmethod(_xmm._MODELGROUP_HMM_monitor_training)

    def set_trainingCallback(self, callback, extradata):
        return _xmm._MODELGROUP_HMM_set_trainingCallback(self, callback, extradata)

    def performance_init(self):
        return _xmm._MODELGROUP_HMM_performance_init(self)

    def update_likelihood_results(self):
        return _xmm._MODELGROUP_HMM_update_likelihood_results(self)
    __swig_setmethods__["models"] = _xmm._MODELGROUP_HMM_models_set
    __swig_getmethods__["models"] = _xmm._MODELGROUP_HMM_models_get
    if _newclass:
        models = _swig_property(_xmm._MODELGROUP_HMM_models_get, _xmm._MODELGROUP_HMM_models_set)
    __swig_setmethods__["globalTrainingSet"] = _xmm._MODELGROUP_HMM_globalTrainingSet_set
    __swig_getmethods__["globalTrainingSet"] = _xmm._MODELGROUP_HMM_globalTrainingSet_get
    if _newclass:
        globalTrainingSet = _swig_property(_xmm._MODELGROUP_HMM_globalTrainingSet_get, _xmm._MODELGROUP_HMM_globalTrainingSet_set)
    __swig_setmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_instant_likelihoods_set
    __swig_getmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_instant_likelihoods_get
    if _newclass:
        results_instant_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_instant_likelihoods_get, _xmm._MODELGROUP_HMM_results_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_set
    __swig_getmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_get
    if _newclass:
        results_normalized_instant_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_get, _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_likelihoods_set
    __swig_getmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_likelihoods_get
    if _newclass:
        results_normalized_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_normalized_likelihoods_get, _xmm._MODELGROUP_HMM_results_normalized_likelihoods_set)
    __swig_setmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_HMM_results_log_likelihoods_set
    __swig_getmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_HMM_results_log_likelihoods_get
    if _newclass:
        results_log_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_log_likelihoods_get, _xmm._MODELGROUP_HMM_results_log_likelihoods_set)
    __swig_setmethods__["results_likeliest"] = _xmm._MODELGROUP_HMM_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm._MODELGROUP_HMM_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm._MODELGROUP_HMM_results_likeliest_get, _xmm._MODELGROUP_HMM_results_likeliest_set)
    __swig_setmethods__["results_predicted_output"] = _xmm._MODELGROUP_HMM_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm._MODELGROUP_HMM_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm._MODELGROUP_HMM_results_predicted_output_get, _xmm._MODELGROUP_HMM_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm._MODELGROUP_HMM_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm._MODELGROUP_HMM_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm._MODELGROUP_HMM_results_output_variance_get, _xmm._MODELGROUP_HMM_results_output_variance_set)
_MODELGROUP_HMM_swigregister = _xmm._MODELGROUP_HMM_swigregister
_MODELGROUP_HMM_swigregister(_MODELGROUP_HMM)

def _MODELGROUP_HMM_monitor_training(model, state, extradata):
    return _xmm._MODELGROUP_HMM_monitor_training(model, state, extradata)
_MODELGROUP_HMM_monitor_training = _xmm._MODELGROUP_HMM_monitor_training

class GMMGroup(_MODELGROUP_GMM):
    """
    Set of GMMs Running in parallel.

    Allows to perform GMM-based pattern recognition. See:  ModelGroup

    C++ includes: gmm_group.h 
    """
    __swig_setmethods__ = {}
    for _s in [_MODELGROUP_GMM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMMGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [_MODELGROUP_GMM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMMGroup, name)
    __repr__ = _swig_repr

    def __init__(self, flags=NONE, globalTrainingSet=None):
        """
        GMMGroup::GMMGroup(rtml_flags flags=NONE, TrainingSet
        *globalTrainingSet=NULL)

        Constructor.

        Parameters:
        -----------

        globalTrainingSet:  training set associated with the model

        flags:  Construction Flags: use 'BIMODAL' for use with Gaussian
        Mixture Regression. 
        """
        this = _xmm.new_GMMGroup(flags, globalTrainingSet)
        try:
            self.this.append(this)
        except:
            self.this = this

    def get_nbMixtureComponents(self):
        """
        int
        GMMGroup::get_nbMixtureComponents() const

        Get the number of Gaussian mixture Components.

        number of Gaussian mixture components 
        """
        return _xmm.GMMGroup_get_nbMixtureComponents(self)


    def get_varianceOffset_relative(self):
        """
        double
        GMMGroup::get_varianceOffset_relative() const

        Get Offset added to covariance matrices for convergence (Relative to
        data variance)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.GMMGroup_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double
        GMMGroup::get_varianceOffset_absolute() const

        Get Offset added to covariance matrices for convergence (Minimum
        value)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.GMMGroup_get_varianceOffset_absolute(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        GMMGroup::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of mixture components of the model.

        WARNING:  sets the model to be untrained.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian Mixture Components

        Exceptions:
        -----------

        invalid_argument:  if nbMixtureComponents is <= 0 
        """
        return _xmm.GMMGroup_set_nbMixtureComponents(self, nbMixtureComponents)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        GMMGroup::set_varianceOffset(double varianceOffset_relative, double
        varianceOffset_absolute)

        Set the offset to add to the covariance matrices.

        Parameters:
        -----------

        varianceOffset_relative:  offset to add to the diagonal of covariance
        matrices (relative to data variance)

        varianceOffset_absolute:  offset to add to the diagonal of covariance
        matrices (minimum value)

        Exceptions:
        -----------

        invalid_argument:  if the covariance offset is <= 0 
        """
        return _xmm.GMMGroup_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        GMMGroup::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.GMMGroup_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        GMMGroup::set_weight_regression(double weight_regression)

        Get Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.GMMGroup_set_weight_regression(self, weight_regression)


    def performance_update(self, observation):
        """
        void
        GMMGroup::performance_update(vector< float > const &observation)

        Main Play function: performs recognition (unimodal mode) and
        regression (bimodal mode)

        The predicted output is stored in the observation vector in bimodal
        mode

        Parameters:
        -----------

        observation:  observation vector 
        """
        return _xmm.GMMGroup_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        GMMGroup::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.GMMGroup_to_json(self)


    def from_json(self, root):
        """
        void
        GMMGroup::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.GMMGroup_from_json(self, root)

    __swig_destroy__ = _xmm.delete_GMMGroup
    __del__ = lambda self: None
GMMGroup_swigregister = _xmm.GMMGroup_swigregister
GMMGroup_swigregister(GMMGroup)

class HierarchicalHMM(_MODELGROUP_HMM):
    """
    Hierarchical Hidden Markov Model.

    Todo Needs more details

    C++ includes: hierarchical_hmm.h 
    """
    __swig_setmethods__ = {}
    for _s in [_MODELGROUP_HMM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HierarchicalHMM, name, value)
    __swig_getmethods__ = {}
    for _s in [_MODELGROUP_HMM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HierarchicalHMM, name)
    __repr__ = _swig_repr

    def __init__(self, flags=NONE, _globalTrainingSet=None):
        """
        HierarchicalHMM::HierarchicalHMM(rtml_flags flags=NONE, TrainingSet
        *_globalTrainingSet=NULL) 
        """
        this = _xmm.new_HierarchicalHMM(flags, _globalTrainingSet)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_HierarchicalHMM
    __del__ = lambda self: None

    def clear(self):
        """
        void
        HierarchicalHMM::clear()

        Remove All models. 
        """
        return _xmm.HierarchicalHMM_clear(self)


    def get_nbStates(self):
        """
        int
        HierarchicalHMM::get_nbStates() const

        Get the Number of hidden states of the model.

        number of hidden states 
        """
        return _xmm.HierarchicalHMM_get_nbStates(self)


    def set_nbStates(self, nbStates):
        """
        void
        HierarchicalHMM::set_nbStates(int nbStates)

        Set the number of hidden states of the model.

        sets the mode to be untrained

        Parameters:
        -----------

        nbStates:  number of hidden states

        Exceptions:
        -----------

        invalid_argument:  if the number of states is <= 0 
        """
        return _xmm.HierarchicalHMM_set_nbStates(self, nbStates)


    def get_nbMixtureComponents(self):
        """
        int
        HierarchicalHMM::get_nbMixtureComponents() const

        Get the number of Gaussian mixture components of the observation
        probability distribution.

        number of Gaussian mixture components 
        """
        return _xmm.HierarchicalHMM_get_nbMixtureComponents(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        HierarchicalHMM::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of Gaussian mixture components of the observation
        probability distribution.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian mixture components

        Exceptions:
        -----------

        invalid_argument:  if the number of Gaussian mixture components is <=
        0 
        """
        return _xmm.HierarchicalHMM_set_nbMixtureComponents(self, nbMixtureComponents)


    def get_varianceOffset_relative(self):
        """
        double HierarchicalHMM::get_varianceOffset_relative() const

        Get Offset added to covariance matrices for convergence (Relative to
        data variance)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.HierarchicalHMM_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double HierarchicalHMM::get_varianceOffset_absolute() const

        Get Offset added to covariance matrices for convergence (Minimum
        value)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.HierarchicalHMM_get_varianceOffset_absolute(self)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        HierarchicalHMM::set_varianceOffset(double varianceOffset_relative,
        double varianceOffset_absolute)

        Set the offset to add to the covariance matrices.

        Parameters:
        -----------

        varianceOffset_relative:  offset to add to the diagonal of covariance
        matrices (relative to data variance)

        varianceOffset_absolute:  offset to add to the diagonal of covariance
        matrices (minimum value)

        Exceptions:
        -----------

        invalid_argument:  if the covariance offset is <= 0 
        """
        return _xmm.HierarchicalHMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        HierarchicalHMM::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.HierarchicalHMM_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        HierarchicalHMM::set_weight_regression(double weight_regression)

        Get Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.HierarchicalHMM_set_weight_regression(self, weight_regression)


    def get_regression_estimator(self):
        """
        REGRESSION_ESTIMATOR HierarchicalHMM::get_regression_estimator() const

        Get the regression estimator type.

        regression estimator type

        See:   REGRESSION_ESTIMATOR 
        """
        return _xmm.HierarchicalHMM_get_regression_estimator(self)


    def set_regression_estimator(self, regression_estimator):
        """
        void HierarchicalHMM::set_regression_estimator(REGRESSION_ESTIMATOR
        regression_estimator)

        Set the regression estimator type.

        Parameters:
        -----------

        regression_estimator:  type of estimator

        See:   REGRESSION_ESTIMATOR 
        """
        return _xmm.HierarchicalHMM_set_regression_estimator(self, regression_estimator)


    def get_transitionMode(self):
        """
        string
        HierarchicalHMM::get_transitionMode() const

        get transition mode of the hidden Markov Chain

        string corresponding to the transition mode (left-right / ergodic) 
        """
        return _xmm.HierarchicalHMM_get_transitionMode(self)


    def set_transitionMode(self, transMode_str):
        """
        void
        HierarchicalHMM::set_transitionMode(string transMode_str)

        set transition mode of the hidden Markov Chain

        Parameters:
        -----------

        transMode_str:  string keyword corresponding to the transition mode
        ("left-right" / "ergodic")

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "left-right" or
        "ergodic" 
        """
        return _xmm.HierarchicalHMM_set_transitionMode(self, transMode_str)


    def get_estimateMeans(self):
        """
        bool
        HierarchicalHMM::get_estimateMeans() const 
        """
        return _xmm.HierarchicalHMM_get_estimateMeans(self)


    def set_estimateMeans(self, _estimateMeans):
        """
        void
        HierarchicalHMM::set_estimateMeans(bool _estimateMeans) 
        """
        return _xmm.HierarchicalHMM_set_estimateMeans(self, _estimateMeans)


    def addExitPoint(self, state, proba):
        """
        void
        HierarchicalHMM::addExitPoint(int state, float proba) 
        """
        return _xmm.HierarchicalHMM_addExitPoint(self, state, proba)


    def get_learningMode(self):
        """
        string
        HierarchicalHMM::get_learningMode() const

        return learning mode: "incremental" or "ergodic"

        if ergodic, each time a model is added at the high level, the
        transition matrix is reset to ergodic. if "incremental", the
        transitions are updated using regularization learningMode
        "incremental" or "ergodic" 
        """
        return _xmm.HierarchicalHMM_get_learningMode(self)


    def set_learningMode(self, learningMode):
        """
        void
        HierarchicalHMM::set_learningMode(string learningMode)

        set learning mode: "incremental" or "ergodic"

        if ergodic, each time a model is added at the high level, the
        transition matrix is reset to ergodic. if "incremental", the
        transitions are updated using regularization

        Parameters:
        -----------

        learningMode:  "incremental" or "ergodic"

        Exceptions:
        -----------

        invalid_argument:  if the argument is neither "incremental" nor
        "ergodic" 
        """
        return _xmm.HierarchicalHMM_set_learningMode(self, learningMode)


    def get_prior(self, prior):
        """
        void
        HierarchicalHMM::get_prior(vector< double > &prior) const

        get a copy of the high-level Prior probabilities vector

        Parameters:
        -----------

        prior:  output High-level prior probability vector 
        """
        return _xmm.HierarchicalHMM_get_prior(self, prior)


    def set_prior(self, prior):
        """
        void
        HierarchicalHMM::set_prior(vector< double > const &prior)

        set high-level prior probabilities vector

        Parameters:
        -----------

        prior:  high-level probability vector (size nbPrimitives)

        Exceptions:
        -----------

        invalid_argument:  if the array has a wrong format (not enough values)

        WARNING:  the models are ordered in ascending order by label 
        """
        return _xmm.HierarchicalHMM_set_prior(self, prior)


    def get_transition(self, trans):
        """
        void
        HierarchicalHMM::get_transition(vector< double > &trans) const

        get a copy of the high-level transition matrix

        Parameters:
        -----------

        trans:  output high-level transition matrix 
        """
        return _xmm.HierarchicalHMM_get_transition(self, trans)


    def set_transition(self, trans):
        """
        void
        HierarchicalHMM::set_transition(vector< double > const &trans)

        set the high-level transition matrix

        Parameters:
        -----------

        trans:  high-level transition matrix

        Exceptions:
        -----------

        invalid_argument:  if the array has a wrong format (not enough values)

        WARNING:  the models are ordered in ascending order by label 
        """
        return _xmm.HierarchicalHMM_set_transition(self, trans)


    def get_exitTransition(self, trans):
        """
        void
        HierarchicalHMM::get_exitTransition(vector< double > &trans) const

        get a copy of the high-level exit probabilities

        exit probabilities are the probabilities to finish and go back to the
        root

        Parameters:
        -----------

        trans:  output exit transition vector of the high level 
        """
        return _xmm.HierarchicalHMM_get_exitTransition(self, trans)


    def set_exitTransition(self, exittrans):
        """
        void
        HierarchicalHMM::set_exitTransition(vector< double > const &exittrans)

        set the exit transition vector of the high level

        Parameters:
        -----------

        exittrans:  high-level exit probabilities vector

        Exceptions:
        -----------

        invalid_argument:  if the array has a wrong format (not enough values)

        WARNING:  the models are ordered in ascending order by label 
        """
        return _xmm.HierarchicalHMM_set_exitTransition(self, exittrans)


    def setOneTransition(self, srcSegmentLabel, dstSegmentLabel, proba):
        """
        void
        HierarchicalHMM::setOneTransition(Label srcSegmentLabel, Label
        dstSegmentLabel, double proba)

        set a particular value of the transition matrix

        sets trans(i,j) = proba

        Parameters:
        -----------

        srcSegmentLabel:  origin segment

        dstSegmentLabel:  target segment

        proba:  probability of making a transition from srcSegmentLabel to
        dstSegmentLabel

        WARNING:  transitions are normalized after the value is set. Todo
        absolute/relative mode? 
        """
        return _xmm.HierarchicalHMM_setOneTransition(self, srcSegmentLabel, dstSegmentLabel, proba)


    def remove(self, label):
        """
        void
        HierarchicalHMM::remove(Label const &label)

        Remove Specific model.

        The method updates the transition parameters

        Parameters:
        -----------

        label:  label of the model

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm.HierarchicalHMM_remove(self, label)


    def performance_init(self):
        """
        void
        HierarchicalHMM::performance_init()

        Initialize performance mode. 
        """
        return _xmm.HierarchicalHMM_performance_init(self)


    def performance_update(self, observation):
        """
        void
        HierarchicalHMM::performance_update(vector< float > const
        &observation)

        Main performance Function: perform joint recognition and mapping (in
        the case of a bimodal model)

        Parameters:
        -----------

        observation:  observation vector. If the model is bimodal, this should
        be allocated for both modalities, and should contain the observation
        on the input modality. The predicted output will be appended to the
        input modality observation 
        """
        return _xmm.HierarchicalHMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        HierarchicalHMM::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.HierarchicalHMM_to_json(self)


    def from_json(self, root):
        """
        void
        HierarchicalHMM::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.HierarchicalHMM_from_json(self, root)

    __swig_setmethods__["prior"] = _xmm.HierarchicalHMM_prior_set
    __swig_getmethods__["prior"] = _xmm.HierarchicalHMM_prior_get
    if _newclass:
        prior = _swig_property(_xmm.HierarchicalHMM_prior_get, _xmm.HierarchicalHMM_prior_set)
    __swig_setmethods__["exitTransition"] = _xmm.HierarchicalHMM_exitTransition_set
    __swig_getmethods__["exitTransition"] = _xmm.HierarchicalHMM_exitTransition_get
    if _newclass:
        exitTransition = _swig_property(_xmm.HierarchicalHMM_exitTransition_get, _xmm.HierarchicalHMM_exitTransition_set)
    __swig_setmethods__["transition"] = _xmm.HierarchicalHMM_transition_set
    __swig_getmethods__["transition"] = _xmm.HierarchicalHMM_transition_get
    if _newclass:
        transition = _swig_property(_xmm.HierarchicalHMM_transition_get, _xmm.HierarchicalHMM_transition_set)
HierarchicalHMM_swigregister = _xmm.HierarchicalHMM_swigregister
HierarchicalHMM_swigregister(HierarchicalHMM)
HHMM_DEFAULT_EXITTRANSITION = cvar.HHMM_DEFAULT_EXITTRANSITION
HHMM_DEFAULT_INCREMENTALLEARNING = cvar.HHMM_DEFAULT_INCREMENTALLEARNING
HHMM_DEFAULT_REGULARIZATIONFACTOR = cvar.HHMM_DEFAULT_REGULARIZATIONFACTOR

# This file is compatible with both classic and new-style classes.


