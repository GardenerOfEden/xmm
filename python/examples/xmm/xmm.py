# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Multimodal Hidden Markov Models Library
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_xmm', [dirname(__file__)])
        except ImportError:
            import _xmm
            return _xmm
        if fp is not None:
            try:
                _mod = imp.load_module('_xmm', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _xmm = swig_import_helper()
    del swig_import_helper
else:
    import _xmm
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _xmm.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _xmm.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _xmm.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _xmm.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _xmm.SwigPyIterator_equal(self, x)

    def copy(self):
        return _xmm.SwigPyIterator_copy(self)

    def next(self):
        return _xmm.SwigPyIterator_next(self)

    def __next__(self):
        return _xmm.SwigPyIterator___next__(self)

    def previous(self):
        return _xmm.SwigPyIterator_previous(self)

    def advance(self, n):
        return _xmm.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _xmm.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _xmm.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _xmm.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _xmm.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _xmm.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _xmm.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _xmm.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectord___nonzero__(self)

    def __bool__(self):
        return _xmm.vectord___bool__(self)

    def __len__(self):
        return _xmm.vectord___len__(self)

    def pop(self):
        return _xmm.vectord_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectord___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectord_append(self, x)

    def empty(self):
        return _xmm.vectord_empty(self)

    def size(self):
        return _xmm.vectord_size(self)

    def clear(self):
        return _xmm.vectord_clear(self)

    def swap(self, v):
        return _xmm.vectord_swap(self, v)

    def get_allocator(self):
        return _xmm.vectord_get_allocator(self)

    def begin(self):
        return _xmm.vectord_begin(self)

    def end(self):
        return _xmm.vectord_end(self)

    def rbegin(self):
        return _xmm.vectord_rbegin(self)

    def rend(self):
        return _xmm.vectord_rend(self)

    def pop_back(self):
        return _xmm.vectord_pop_back(self)

    def erase(self, *args):
        return _xmm.vectord_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectord(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectord_push_back(self, x)

    def front(self):
        return _xmm.vectord_front(self)

    def back(self):
        return _xmm.vectord_back(self)

    def assign(self, n, x):
        return _xmm.vectord_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectord_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectord_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectord_reserve(self, n)

    def capacity(self):
        return _xmm.vectord_capacity(self)
    __swig_destroy__ = _xmm.delete_vectord
    __del__ = lambda self: None
vectord_swigregister = _xmm.vectord_swigregister
vectord_swigregister(vectord)

class vectorf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorf, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorf___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorf___bool__(self)

    def __len__(self):
        return _xmm.vectorf___len__(self)

    def pop(self):
        return _xmm.vectorf_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorf___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorf_append(self, x)

    def empty(self):
        return _xmm.vectorf_empty(self)

    def size(self):
        return _xmm.vectorf_size(self)

    def clear(self):
        return _xmm.vectorf_clear(self)

    def swap(self, v):
        return _xmm.vectorf_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorf_get_allocator(self)

    def begin(self):
        return _xmm.vectorf_begin(self)

    def end(self):
        return _xmm.vectorf_end(self)

    def rbegin(self):
        return _xmm.vectorf_rbegin(self)

    def rend(self):
        return _xmm.vectorf_rend(self)

    def pop_back(self):
        return _xmm.vectorf_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorf_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorf(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorf_push_back(self, x)

    def front(self):
        return _xmm.vectorf_front(self)

    def back(self):
        return _xmm.vectorf_back(self)

    def assign(self, n, x):
        return _xmm.vectorf_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorf_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorf_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorf_reserve(self, n)

    def capacity(self):
        return _xmm.vectorf_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorf
    __del__ = lambda self: None
vectorf_swigregister = _xmm.vectorf_swigregister
vectorf_swigregister(vectorf)

class vectorgauss(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorgauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorgauss, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorgauss_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorgauss___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorgauss___bool__(self)

    def __len__(self):
        return _xmm.vectorgauss___len__(self)

    def pop(self):
        return _xmm.vectorgauss_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorgauss___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorgauss___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorgauss___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorgauss___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorgauss___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorgauss___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorgauss_append(self, x)

    def empty(self):
        return _xmm.vectorgauss_empty(self)

    def size(self):
        return _xmm.vectorgauss_size(self)

    def clear(self):
        return _xmm.vectorgauss_clear(self)

    def swap(self, v):
        return _xmm.vectorgauss_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorgauss_get_allocator(self)

    def begin(self):
        return _xmm.vectorgauss_begin(self)

    def end(self):
        return _xmm.vectorgauss_end(self)

    def rbegin(self):
        return _xmm.vectorgauss_rbegin(self)

    def rend(self):
        return _xmm.vectorgauss_rend(self)

    def pop_back(self):
        return _xmm.vectorgauss_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorgauss_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorgauss(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorgauss_push_back(self, x)

    def front(self):
        return _xmm.vectorgauss_front(self)

    def back(self):
        return _xmm.vectorgauss_back(self)

    def assign(self, n, x):
        return _xmm.vectorgauss_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorgauss_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorgauss_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorgauss_reserve(self, n)

    def capacity(self):
        return _xmm.vectorgauss_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorgauss
    __del__ = lambda self: None
vectorgauss_swigregister = _xmm.vectorgauss_swigregister
vectorgauss_swigregister(vectorgauss)

class vectorgmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorgmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorgmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorgmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorgmm___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorgmm___bool__(self)

    def __len__(self):
        return _xmm.vectorgmm___len__(self)

    def pop(self):
        return _xmm.vectorgmm_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorgmm___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorgmm___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorgmm___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorgmm___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorgmm___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorgmm___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorgmm_append(self, x)

    def empty(self):
        return _xmm.vectorgmm_empty(self)

    def size(self):
        return _xmm.vectorgmm_size(self)

    def clear(self):
        return _xmm.vectorgmm_clear(self)

    def swap(self, v):
        return _xmm.vectorgmm_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorgmm_get_allocator(self)

    def begin(self):
        return _xmm.vectorgmm_begin(self)

    def end(self):
        return _xmm.vectorgmm_end(self)

    def rbegin(self):
        return _xmm.vectorgmm_rbegin(self)

    def rend(self):
        return _xmm.vectorgmm_rend(self)

    def pop_back(self):
        return _xmm.vectorgmm_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorgmm_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorgmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorgmm_push_back(self, x)

    def front(self):
        return _xmm.vectorgmm_front(self)

    def back(self):
        return _xmm.vectorgmm_back(self)

    def assign(self, n, x):
        return _xmm.vectorgmm_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorgmm_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorgmm_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorgmm_reserve(self, n)

    def capacity(self):
        return _xmm.vectorgmm_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorgmm
    __del__ = lambda self: None
vectorgmm_swigregister = _xmm.vectorgmm_swigregister
vectorgmm_swigregister(vectorgmm)

class vectorhmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorhmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorhmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.vectorhmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.vectorhmm___nonzero__(self)

    def __bool__(self):
        return _xmm.vectorhmm___bool__(self)

    def __len__(self):
        return _xmm.vectorhmm___len__(self)

    def pop(self):
        return _xmm.vectorhmm_pop(self)

    def __getslice__(self, i, j):
        return _xmm.vectorhmm___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _xmm.vectorhmm___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _xmm.vectorhmm___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _xmm.vectorhmm___delitem__(self, *args)

    def __getitem__(self, *args):
        return _xmm.vectorhmm___getitem__(self, *args)

    def __setitem__(self, *args):
        return _xmm.vectorhmm___setitem__(self, *args)

    def append(self, x):
        return _xmm.vectorhmm_append(self, x)

    def empty(self):
        return _xmm.vectorhmm_empty(self)

    def size(self):
        return _xmm.vectorhmm_size(self)

    def clear(self):
        return _xmm.vectorhmm_clear(self)

    def swap(self, v):
        return _xmm.vectorhmm_swap(self, v)

    def get_allocator(self):
        return _xmm.vectorhmm_get_allocator(self)

    def begin(self):
        return _xmm.vectorhmm_begin(self)

    def end(self):
        return _xmm.vectorhmm_end(self)

    def rbegin(self):
        return _xmm.vectorhmm_rbegin(self)

    def rend(self):
        return _xmm.vectorhmm_rend(self)

    def pop_back(self):
        return _xmm.vectorhmm_pop_back(self)

    def erase(self, *args):
        return _xmm.vectorhmm_erase(self, *args)

    def __init__(self, *args):
        this = _xmm.new_vectorhmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def push_back(self, x):
        return _xmm.vectorhmm_push_back(self, x)

    def front(self):
        return _xmm.vectorhmm_front(self)

    def back(self):
        return _xmm.vectorhmm_back(self)

    def assign(self, n, x):
        return _xmm.vectorhmm_assign(self, n, x)

    def resize(self, *args):
        return _xmm.vectorhmm_resize(self, *args)

    def insert(self, *args):
        return _xmm.vectorhmm_insert(self, *args)

    def reserve(self, n):
        return _xmm.vectorhmm_reserve(self, n)

    def capacity(self):
        return _xmm.vectorhmm_capacity(self)
    __swig_destroy__ = _xmm.delete_vectorhmm
    __del__ = lambda self: None
vectorhmm_swigregister = _xmm.vectorhmm_swigregister
vectorhmm_swigregister(vectorhmm)

class mapgmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mapgmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mapgmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.mapgmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.mapgmm___nonzero__(self)

    def __bool__(self):
        return _xmm.mapgmm___bool__(self)

    def __len__(self):
        return _xmm.mapgmm___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _xmm.mapgmm___getitem__(self, key)

    def __delitem__(self, key):
        return _xmm.mapgmm___delitem__(self, key)

    def has_key(self, key):
        return _xmm.mapgmm_has_key(self, key)

    def keys(self):
        return _xmm.mapgmm_keys(self)

    def values(self):
        return _xmm.mapgmm_values(self)

    def items(self):
        return _xmm.mapgmm_items(self)

    def __contains__(self, key):
        return _xmm.mapgmm___contains__(self, key)

    def key_iterator(self):
        return _xmm.mapgmm_key_iterator(self)

    def value_iterator(self):
        return _xmm.mapgmm_value_iterator(self)

    def __setitem__(self, *args):
        return _xmm.mapgmm___setitem__(self, *args)

    def asdict(self):
        return _xmm.mapgmm_asdict(self)

    def __init__(self, *args):
        this = _xmm.new_mapgmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _xmm.mapgmm_empty(self)

    def size(self):
        return _xmm.mapgmm_size(self)

    def clear(self):
        return _xmm.mapgmm_clear(self)

    def swap(self, v):
        return _xmm.mapgmm_swap(self, v)

    def get_allocator(self):
        return _xmm.mapgmm_get_allocator(self)

    def begin(self):
        return _xmm.mapgmm_begin(self)

    def end(self):
        return _xmm.mapgmm_end(self)

    def rbegin(self):
        return _xmm.mapgmm_rbegin(self)

    def rend(self):
        return _xmm.mapgmm_rend(self)

    def count(self, x):
        return _xmm.mapgmm_count(self, x)

    def erase(self, *args):
        return _xmm.mapgmm_erase(self, *args)

    def find(self, x):
        return _xmm.mapgmm_find(self, x)

    def lower_bound(self, x):
        return _xmm.mapgmm_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.mapgmm_upper_bound(self, x)
    __swig_destroy__ = _xmm.delete_mapgmm
    __del__ = lambda self: None
mapgmm_swigregister = _xmm.mapgmm_swigregister
mapgmm_swigregister(mapgmm)

class maphmm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maphmm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maphmm, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _xmm.maphmm_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _xmm.maphmm___nonzero__(self)

    def __bool__(self):
        return _xmm.maphmm___bool__(self)

    def __len__(self):
        return _xmm.maphmm___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _xmm.maphmm___getitem__(self, key)

    def __delitem__(self, key):
        return _xmm.maphmm___delitem__(self, key)

    def has_key(self, key):
        return _xmm.maphmm_has_key(self, key)

    def keys(self):
        return _xmm.maphmm_keys(self)

    def values(self):
        return _xmm.maphmm_values(self)

    def items(self):
        return _xmm.maphmm_items(self)

    def __contains__(self, key):
        return _xmm.maphmm___contains__(self, key)

    def key_iterator(self):
        return _xmm.maphmm_key_iterator(self)

    def value_iterator(self):
        return _xmm.maphmm_value_iterator(self)

    def __setitem__(self, *args):
        return _xmm.maphmm___setitem__(self, *args)

    def asdict(self):
        return _xmm.maphmm_asdict(self)

    def __init__(self, *args):
        this = _xmm.new_maphmm(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def empty(self):
        return _xmm.maphmm_empty(self)

    def size(self):
        return _xmm.maphmm_size(self)

    def clear(self):
        return _xmm.maphmm_clear(self)

    def swap(self, v):
        return _xmm.maphmm_swap(self, v)

    def get_allocator(self):
        return _xmm.maphmm_get_allocator(self)

    def begin(self):
        return _xmm.maphmm_begin(self)

    def end(self):
        return _xmm.maphmm_end(self)

    def rbegin(self):
        return _xmm.maphmm_rbegin(self)

    def rend(self):
        return _xmm.maphmm_rend(self)

    def count(self, x):
        return _xmm.maphmm_count(self, x)

    def erase(self, *args):
        return _xmm.maphmm_erase(self, *args)

    def find(self, x):
        return _xmm.maphmm_find(self, x)

    def lower_bound(self, x):
        return _xmm.maphmm_lower_bound(self, x)

    def upper_bound(self, x):
        return _xmm.maphmm_upper_bound(self, x)
    __swig_destroy__ = _xmm.delete_maphmm
    __del__ = lambda self: None
maphmm_swigregister = _xmm.maphmm_swigregister
maphmm_swigregister(maphmm)


_xmm.NONE_swigconstant(_xmm)
NONE = _xmm.NONE

_xmm.SHARED_MEMORY_swigconstant(_xmm)
SHARED_MEMORY = _xmm.SHARED_MEMORY

_xmm.BIMODAL_swigconstant(_xmm)
BIMODAL = _xmm.BIMODAL

_xmm.HIERARCHICAL_swigconstant(_xmm)
HIERARCHICAL = _xmm.HIERARCHICAL
class Listener(_object):
    """
    Abstract class for handling training set notifications.

    It is an abstract class that contains a pure virtual method "notify"
    called by a training set to notify changes of the training data

    C++ includes: mbd_common.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Listener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Listener, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_Listener
    __del__ = lambda self: None

    def notify(self, attribute):
        """
        virtual void
        Listener::notify(string attribute)=0

        pure virtual method for handling training set notifications.

        Parameters:
        -----------

        attribute:  name of the modified attribute of the training set 
        """
        return _xmm.Listener_notify(self, attribute)

Listener_swigregister = _xmm.Listener_swigregister
Listener_swigregister(Listener)
cvar = _xmm.cvar
NULLVEC_FLOAT = cvar.NULLVEC_FLOAT
NULLVEC_DOUBLE = cvar.NULLVEC_DOUBLE

class Writable(_object):
    """
    Abstract class for handling JSON + File I/O.

    the JSON I/O methods need to be implemented. writeFile and readFile
    methods can be used in Python for file I/O. The str() Python method is
    implemented to use with "print" in Python. It return the pretty-
    printed JSON String.

    C++ includes: mbd_common.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Writable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Writable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_Writable
    __del__ = lambda self: None

    def to_json(self):
        """
        virtual JSONNode
        Writable::to_json() const =0

        Write to JSON Node.

        JSON Node containing phrase information 
        """
        return _xmm.Writable_to_json(self)


    def from_json(self, root):
        """
        virtual void
        Writable::from_json(JSONNode root)=0

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.Writable_from_json(self, root)


    def writeFile(self, fileName):
        """
        void
        Writable::writeFile(char *fileName)

        write method for python wrapping ('write' keyword forbidden, name has
        to be different)

        WARNING:  only defined if SWIGPYTHON is defined 
        """
        return _xmm.Writable_writeFile(self, fileName)


    def readFile(self, fileName):
        """
        void
        Writable::readFile(char *fileName)

        read method for python wrapping ('read' keyword forbidden, name has to
        be different)

        WARNING:  only defined if SWIGPYTHON is defined 
        """
        return _xmm.Writable_readFile(self, fileName)


    def __str__(self):
        """
        string Writable::__str__()

        "print" method for python => returns the results of write method

        WARNING:  only defined if SWIGPYTHON is defined 
        """
        return _xmm.Writable___str__(self)

Writable_swigregister = _xmm.Writable_swigregister
Writable_swigregister(Writable)

class Phrase(Writable):
    """
    Data phrase.

    The Phrase class can be used to store unimodal and Bimodal data
    phrases. It can have an autonomous memory, or this memory can be
    shared with another data container. This can be specified by using the
    'SHARED_MEMORY' flag in the constructor. The phrase can be either
    unimodal - i.e. it contains a single 2D array to store the data, - or
    bimodal - i.e. it contains 2 arrays to store the input and output
    modalities. The latter case can be specified by using the 'BIMODAL'
    flag in the constructor.

    C++ includes: phrase.h 
    """
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Phrase, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Phrase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Phrase::Phrase(Phrase const
        &src)

        Copy Constructor.

        Parameters:
        -----------

        src:  source Phrase 
        """
        this = _xmm.new_Phrase(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_Phrase
    __del__ = lambda self: None

    def is_empty(self):
        """
        bool Phrase::is_empty()
        const

        Checks if the phrase is empty (length 0) 
        """
        return _xmm.Phrase_is_empty(self)


    def __eq__(self, src):
        return _xmm.Phrase___eq__(self, src)

    def __ne__(self, src):
        return _xmm.Phrase___ne__(self, src)

    def length(self):
        """
        unsigned int Phrase::length()
        const

        length of the phrase 
        """
        return _xmm.Phrase_length(self)


    def trim(self, *args):
        """
        void Phrase::trim()

        trim phrase to minimal length of modalities 
        """
        return _xmm.Phrase_trim(self, *args)


    def dimension(self):
        """
        unsigned int
        Phrase::dimension() const

        total dimension of the data 
        """
        return _xmm.Phrase_dimension(self)


    def dimension_input(self):
        """
        unsigned int
        Phrase::dimension_input() const

        dimension of the input modality 
        """
        return _xmm.Phrase_dimension_input(self)


    def dimension_output(self):
        """
        unsigned int
        Phrase::dimension_output() const

        dimension of the output modality 
        """
        return _xmm.Phrase_dimension_output(self)


    def set_dimension(self, dimension):
        """
        void
        Phrase::set_dimension(unsigned int dimension)

        Set total dimension

        Parameters:
        -----------

        dimension:  target dimension

        Exceptions:
        -----------

        domain_error:  if dimension < 1 
        """
        return _xmm.Phrase_set_dimension(self, dimension)


    def set_dimension_input(self, dimension_input):
        """
        void
        Phrase::set_dimension_input(unsigned int dimension_input)

        Set dimension of the input modality

        Parameters:
        -----------

        dimension_input:  target dimension

        Exceptions:
        -----------

        runtime_error:  if the phrase is not bimodal

        invalid_argument:  if The dimension of the input modality exceeds the
        total dimension 
        """
        return _xmm.Phrase_set_dimension_input(self, dimension_input)


    def connect(self, *args):
        """
        void Phrase::connect(float
        *pointer_to_data_input, float *pointer_to_data_output, unsigned int
        length)

        Connect a Bimodal phrase to a shared container.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Parameters:
        -----------

        pointer_to_data_input:  pointer to the data array of the input
        modality

        pointer_to_data_output:  pointer to the data array of the output
        modality

        length:  length of the data array

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_connect(self, *args)


    def connect_input(self, pointer_to_data, length):
        """
        void
        Phrase::connect_input(float *pointer_to_data, unsigned int length)

        Connect a Bimodal phrase to a shared container for the input modality.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Parameters:
        -----------

        pointer_to_data:  pointer to the data array of the input modality

        length:  length of the data array

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_connect_input(self, pointer_to_data, length)


    def connect_output(self, pointer_to_data, length):
        """
        void
        Phrase::connect_output(float *pointer_to_data, unsigned int length)

        Connect a Bimodal phrase to a shared container for the output
        modality.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Parameters:
        -----------

        pointer_to_data:  pointer to the data array of the output modality

        length:  length of the data array

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_connect_output(self, pointer_to_data, length)


    def disconnect(self):
        """
        void Phrase::disconnect()

        Disconnect a phrase from a shared container.

        WARNING:  This method is only usable in Shared Memory (construction
        with SHARED_MEMORY flag)

        Exceptions:
        -----------

        runtime_error:  if phrase has own Data 
        """
        return _xmm.Phrase_disconnect(self)


    def record(self, observation):
        """
        void Phrase::record(vector<
        float > const &observation)

        Record observation.

        Appends the observation vector observation to the data array. This
        method is only usable in Own Memory (no SHARED_MEMORY flag)

        Parameters:
        -----------

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.Phrase_record(self, observation)


    def record_input(self, observation):
        """
        void
        Phrase::record_input(vector< float > const &observation)

        Record observation on input modality Appends the observation vector
        observation to the data array This method is only usable in Own Memory
        (no SHARED_MEMORY flag)

        Parameters:
        -----------

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (ownData == false) 
        """
        return _xmm.Phrase_record_input(self, observation)


    def record_output(self, observation):
        """
        void
        Phrase::record_output(vector< float > const &observation)

        Record observation on output modality Appends the observation vector
        observation to the data array This method is only usable in Own Memory
        (no SHARED_MEMORY flag)

        Parameters:
        -----------

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.Phrase_record_output(self, observation)


    def clear(self):
        """
        void Phrase::clear()

        Reset length of the phrase to 0 ==> empty phrase .

        WARNING:  the memory is not released (only done in destructor).

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.Phrase_clear(self)


    def at(self, index, dim):
        """
        float Phrase::at(unsigned int
        index, unsigned int dim) const

        Access data at a given time index and dimension.

        Parameters:
        -----------

        index:  time index

        dim:  dimension considered, indexed from 0 to the total dimension of
        the data across modalities

        Exceptions:
        -----------

        out_of_range:  if time index or dimension are out of bounds 
        """
        return _xmm.Phrase_at(self, index, dim)


    def __call__(self, index, dim):
        return _xmm.Phrase___call__(self, index, dim)

    def get_dataPointer(self, index):
        """
        float *
        Phrase::get_dataPointer(unsigned int index) const

        Get pointer to the data at a given time index.

        Parameters:
        -----------

        index:  time index

        WARNING:  this method can be used only for unimodal phrases (no
        BIMODAL flag)

        Exceptions:
        -----------

        out_of_range:  if time index is out of bounds

        runtime_error:  if the phrase is bimodal

        pointer to the data array of the modality, for the given time index 
        """
        return _xmm.Phrase_get_dataPointer(self, index)


    def get_dataPointer_input(self, index):
        """
        float *
        Phrase::get_dataPointer_input(unsigned int index) const

        Get pointer to the data at a given time index for the input modality.

        WARNING:  this method can be used only for bimodal phrases
        (construction with BIMODAL flag)

        Parameters:
        -----------

        index:  time index

        Exceptions:
        -----------

        out_of_range:  if time index is out of bounds

        runtime_error:  if the phrase is unimodal

        pointer to the data array of the modality, for the given time index 
        """
        return _xmm.Phrase_get_dataPointer_input(self, index)


    def get_dataPointer_output(self, index):
        """
        float *
        Phrase::get_dataPointer_output(unsigned int index) const

        Get pointer to the data at a given time index for the output modality.

        WARNING:  this method can be used only for bimodal phrases
        (construction with BIMODAL flag)

        Parameters:
        -----------

        index:  time index

        Exceptions:
        -----------

        out_of_range:  if time index is out of bounds

        runtime_error:  if the phrase is unimodal

        pointer to the data array of the modality, for the given time index 
        """
        return _xmm.Phrase_get_dataPointer_output(self, index)


    def to_json(self):
        """
        JSONNode Phrase::to_json()
        const

        Write to JSON Node.

        JSON Node containing phrase information 
        """
        return _xmm.Phrase_to_json(self)


    def from_json(self, root):
        """
        void
        Phrase::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing phrase information

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.Phrase_from_json(self, root)


    def mean(self):
        """
        vector< float > Phrase::mean()
        const

        Compute the mean of the data phrase along the time axis.

        mean of the phrase (along time axis, full-size) 
        """
        return _xmm.Phrase_mean(self)


    def variance(self):
        """
        vector< float >
        Phrase::variance() const

        Compute the variance of the data phrase along the time axis.

        variance of the phrase (along time axis, full-size) 
        """
        return _xmm.Phrase_variance(self)

Phrase_swigregister = _xmm.Phrase_swigregister
Phrase_swigregister(Phrase)
PHRASE_DEFAULT_DIMENSION = cvar.PHRASE_DEFAULT_DIMENSION
PHRASE_ALLOC_BLOCKSIZE = cvar.PHRASE_ALLOC_BLOCKSIZE

class Label(Writable):
    """
    Label of a data phrase.

    Possible types are int and string

    C++ includes: label.h 
    """
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Label, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Label, name)
    __repr__ = _swig_repr
    INT = _xmm.Label_INT
    SYM = _xmm.Label_SYM
    __swig_setmethods__["type"] = _xmm.Label_type_set
    __swig_getmethods__["type"] = _xmm.Label_type_get
    if _newclass:
        type = _swig_property(_xmm.Label_type_get, _xmm.Label_type_set)
    __swig_destroy__ = _xmm.delete_Label
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        Label::Label(Label const &src)

        Copy Constructor. 
        """
        this = _xmm.new_Label(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def __eq__(self, src):
        return _xmm.Label___eq__(self, src)

    def __ne__(self, src):
        return _xmm.Label___ne__(self, src)

    def __lt__(self, src):
        return _xmm.Label___lt__(self, src)

    def __le__(self, src):
        return _xmm.Label___le__(self, src)

    def __gt__(self, src):
        return _xmm.Label___gt__(self, src)

    def __ge__(self, src):
        return _xmm.Label___ge__(self, src)

    def getInt(self):
        """
        int Label::getInt() const

        Get integer label value

        Exceptions:
        -----------

        runtime_error:  if label type is not INT

        integer label 
        """
        return _xmm.Label_getInt(self)


    def getSym(self):
        """
        string Label::getSym() const

        Get symbolic label value

        Exceptions:
        -----------

        runtime_error:  if label type is not SYM

        symbolic label 
        """
        return _xmm.Label_getSym(self)


    def setInt(self, l):
        """
        void Label::setInt(int l)

        Set integer label value => sets label type to INT

        Parameters:
        -----------

        l:  integer label 
        """
        return _xmm.Label_setInt(self, l)


    def trySetInt(self, l):
        """
        bool Label::trySetInt(string
        l)

        Try to set an integer from a string that contains one.

        Parameters:
        -----------

        l:  integer label stored in a string

        true if the integer label could be set 
        """
        return _xmm.Label_trySetInt(self, l)


    def setSym(self, *args):
        """
        void Label::setSym(char *l)

        Set symbolic label value => sets label type to SYM

        Parameters:
        -----------

        l:  symbolic label as C-string 
        """
        return _xmm.Label_setSym(self, *args)


    def to_json(self):
        """
        JSONNode Label::to_json()
        const

        Write to JSON Node.

        JSON Node containing the label information 
        """
        return _xmm.Label_to_json(self)


    def from_json(self, root):
        """
        void
        Label::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing the label information 
        """
        return _xmm.Label_from_json(self, root)


    def as_string(self):
        """
        string Label::as_string()
        const

        print label as c++ std::string 
        """
        return _xmm.Label_as_string(self)

Label_swigregister = _xmm.Label_swigregister
Label_swigregister(Label)


def is_number(s):
    """
    bool is_number(const string &s)

    Check if the string contains an integer.

    Parameters:
    -----------

    s:  std::string to check

    true if the string contains an integer 
    """
    return _xmm.is_number(s)

def to_int(s):
    """
    int to_int(const string &s)

    Get integer from string. 
    """
    return _xmm.to_int(s)
class TrainingSet(Writable):
    """
    Base class for the definition of (multimodal) training sets.

    Todo Needs more details

    C++ includes: training_set.h 
    """
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrainingSet, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TrainingSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """TrainingSet::TrainingSet(TrainingSet const &src) """
        this = _xmm.new_TrainingSet(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_TrainingSet
    __del__ = lambda self: None

    def is_bimodal(self):
        """
        bool
        TrainingSet::is_bimodal() const

        checks if the training set is bimodal

        true if the training set is bimodal (construction with BIMODAL flag)

        """
        return _xmm.TrainingSet_is_bimodal(self)


    def is_empty(self):
        """
        bool
        TrainingSet::is_empty() const

        checks if the training set is empty

        true if the training set is empty (no training phrases) 
        """
        return _xmm.TrainingSet_is_empty(self)


    def size(self):
        """
        unsigned int
        TrainingSet::size() const

        Size of the training set.

        size of the training set (number of phrases) 
        """
        return _xmm.TrainingSet_size(self)


    def has_changed(self):
        """
        bool
        TrainingSet::has_changed()

        check if the training data has changed.

        true is the training data or attributes have changed 
        """
        return _xmm.TrainingSet_has_changed(self)


    def set_unchanged(self):
        """
        void
        TrainingSet::set_unchanged()

        set the status of the training set to unchanged 
        """
        return _xmm.TrainingSet_set_unchanged(self)


    def add_listener(self, listener):
        """
        void
        TrainingSet::add_listener(Listener *listener)

        Add a listener to the training set. The listeners are notified when an
        attribute (e.g. dimension) of the training set is modified.

        Parameters:
        -----------

        listener:  listener model 
        """
        return _xmm.TrainingSet_add_listener(self, listener)


    def remove_listener(self, listener):
        """
        void
        TrainingSet::remove_listener(Listener *listener)

        Remove a listener form the training set.

        Parameters:
        -----------

        listener:  listener model 
        """
        return _xmm.TrainingSet_remove_listener(self, listener)


    def dimension(self):
        """
        unsigned int
        TrainingSet::dimension()

        Get total dimension of the training data.

        dimension of the training data 
        """
        return _xmm.TrainingSet_dimension(self)


    def dimension_input(self):
        """
        unsigned int
        TrainingSet::dimension_input()

        Get dimension of the input modality in bimodal mode.

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if the phrase is unimodal (no BIMODAL construction
        flag) 
        """
        return _xmm.TrainingSet_dimension_input(self)


    def set_dimension(self, dimension):
        """
        void
        TrainingSet::set_dimension(unsigned int dimension)

        Set total dimension of the training data.

        Parameters:
        -----------

        dimension:  dimension of the training data

        Exceptions:
        -----------

        out_of_range:  if the dimension is < 1 
        """
        return _xmm.TrainingSet_set_dimension(self, dimension)


    def set_dimension_input(self, dimension_input):
        """
        void
        TrainingSet::set_dimension_input(unsigned int dimension_input)

        Set the dimension of the input modality in bimodal mode.

        Parameters:
        -----------

        dimension_input:  dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if the phrase is not bimodal

        invalid_argument:  if The dimension of the input modality exceeds the
        total dimension 
        """
        return _xmm.TrainingSet_set_dimension_input(self, dimension_input)


    def __eq__(self, src):
        return _xmm.TrainingSet___eq__(self, src)

    def __ne__(self, src):
        return _xmm.TrainingSet___ne__(self, src)

    def begin(self):
        """
        TrainingSet::phrase_iterator TrainingSet::begin()

        iterator to the beginning of phrases 
        """
        return _xmm.TrainingSet_begin(self)


    def end(self):
        """
        TrainingSet::phrase_iterator
        TrainingSet::end()

        iterator to the end of phrases 
        """
        return _xmm.TrainingSet_end(self)


    def cbegin(self):
        """
        TrainingSet::const_phrase_iterator TrainingSet::cbegin() const

        constant iterator to the beginning of phrases 
        """
        return _xmm.TrainingSet_cbegin(self)


    def cend(self):
        """
        TrainingSet::const_phrase_iterator TrainingSet::cend() const

        constant iterator to the end of phrases 
        """
        return _xmm.TrainingSet_cend(self)


    def __call__(self, n):
        return _xmm.TrainingSet___call__(self, n)

    def connect(self, *args):
        """
        void
        TrainingSet::connect(int phraseIndex, float *pointer_to_data_input,
        float *pointer_to_data_output, unsigned int length)

        Connect a phrase to the training set (synchronous bimodal case)

        This method is used in shared memory to pass an array to the training
        set. If the phrase does not exist, it is created at the specified
        index.

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set. If it does not
        exist, the phrase is created.

        pointer_to_data_input:  pointer to the data array for the input
        modality

        pointer_to_data_output:  pointer to the data array for the output
        modality

        length:  length of the phrase

        Exceptions:
        -----------

        runtime_error:  if not in shared memory (construction with
        SHARED_MEMORY flag)

        runtime_error:  if bimodal (construction with the BIMODAL flag) 
        """
        return _xmm.TrainingSet_connect(self, *args)


    def recordPhrase(self, phraseIndex, observation):
        """
        void
        TrainingSet::recordPhrase(int phraseIndex, vector< float > const
        &observation)

        Record training data.

        The method appends an observation to the data phrase. The observation
        need to have a size "dimension". In bimodal mode, the observation
        must concatenate input and output observations. A phrase is created if
        it does not exists at the given index

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet

        observation:  observation vector to append to the phrase

        Exceptions:
        -----------

        runtime_errpr:  if phrase has shared memory (construction with
        SHARED_MEMORY flag) 
        """
        return _xmm.TrainingSet_recordPhrase(self, phraseIndex, observation)


    def recordPhrase_input(self, phraseIndex, observation):
        """
        void
        TrainingSet::recordPhrase_input(int phraseIndex, vector< float > const
        &observation)

        Record training data on the input modality.

        The method appends an observation on the input modality to the data
        phrase. size "dimension_input"

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (ownData == false) 
        """
        return _xmm.TrainingSet_recordPhrase_input(self, phraseIndex, observation)


    def recordPhrase_output(self, phraseIndex, observation):
        """
        void
        TrainingSet::recordPhrase_output(int phraseIndex, vector< float >
        const &observation)

        Record training data on the output modality Appends the observation
        vector observation to the data array This method is only usable in Own
        Memory (no SHARED_MEMORY flag)

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet

        observation:  observation vector (C-like array which must have the
        size of the total dimension of the data across all modalities)

        Exceptions:
        -----------

        runtime_error:  if data is shared (construction with SHARED_MEMORY
        flag) 
        """
        return _xmm.TrainingSet_recordPhrase_output(self, phraseIndex, observation)


    def resetPhrase(self, phraseIndex):
        """
        void
        TrainingSet::resetPhrase(int phraseIndex)

        reset phrase to default

        The phrase is set to an empty phrase with the current attributes
        (dimensions, etc). The phrase is created if it does not exists at the
        given index.

        Parameters:
        -----------

        phraseIndex:  index of the data phrase in the trainingSet 
        """
        return _xmm.TrainingSet_resetPhrase(self, phraseIndex)


    def deletePhrase(self, phraseIndex):
        """
        void
        TrainingSet::deletePhrase(int phraseIndex)

        delete a phrase

        WARNING:  if the training set is locked, the phrase iself is not
        deleted (only the reference), i.e. its memory is not released.

        Parameters:
        -----------

        phraseIndex:  index of the phrase

        Exceptions:
        -----------

        out_of_bounds:  if the phrase does not exist 
        """
        return _xmm.TrainingSet_deletePhrase(self, phraseIndex)


    def deletePhrasesOfClass(self, label):
        """
        void
        TrainingSet::deletePhrasesOfClass(Label const &label)

        delete all phrases of a given class

        WARNING:  if the training set is locked, the phrases themselves are
        not deleted (only the references), i.e. their memory is not released.

        Parameters:
        -----------

        label:  label of the class to delete

        Exceptions:
        -----------

        out_of_bounds:  if the label does not exist 
        """
        return _xmm.TrainingSet_deletePhrasesOfClass(self, label)


    def deleteEmptyPhrases(self):
        """
        void
        TrainingSet::deleteEmptyPhrases()

        delete all empty phrases 
        """
        return _xmm.TrainingSet_deleteEmptyPhrases(self)


    def clear(self):
        """
        void TrainingSet::clear()

        delete all phrases

        WARNING:  if the training set is locked, the phrases themselves are
        not deleted (only their references), i.e. their memory is not
        released. 
        """
        return _xmm.TrainingSet_clear(self)


    def setDefaultLabel(self, defLabel):
        """
        void
        TrainingSet::setDefaultLabel(Label const &defLabel)

        set default phrase label for new phrases

        Parameters:
        -----------

        defLabel:  default Label 
        """
        return _xmm.TrainingSet_setDefaultLabel(self, defLabel)


    def setPhraseLabelToDefault(self, phraseIndex):
        """
        void
        TrainingSet::setPhraseLabelToDefault(int phraseIndex)

        set label of a phrase to default

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set

        Exceptions:
        -----------

        out_of_range:  if the phrase does not exist 
        """
        return _xmm.TrainingSet_setPhraseLabelToDefault(self, phraseIndex)


    def setPhraseLabel(self, phraseIndex, label):
        """
        void
        TrainingSet::setPhraseLabel(int phraseIndex, Label const &label)

        set the label of a phrase

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set

        label:  label to set

        Exceptions:
        -----------

        out_of_range:  if the phrase does not exist 
        """
        return _xmm.TrainingSet_setPhraseLabel(self, phraseIndex, label)


    def getPhraseLabel(self, phraseIndex):
        """
        Label
        TrainingSet::getPhraseLabel(int phraseIndex)

        get the current label of a phrase in the training set

        Parameters:
        -----------

        phraseIndex:  index of the phrase in the training set

        label of the phrase 
        """
        return _xmm.TrainingSet_getPhraseLabel(self, phraseIndex)


    def getSubTrainingSetForClass(self, label):
        """
        TrainingSet * TrainingSet::getSubTrainingSetForClass(Label const
        &label)

        get the pointer to the sub-training set containing all phrases with a
        given label

        WARNING:  in order to protect the phrases in the current training set,
        the sub- training set returned is locked

        Parameters:
        -----------

        label:  target label

        pointer to the sub-training set containing all phrases with a given
        label

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm.TrainingSet_getSubTrainingSetForClass(self, label)


    def updateSubTrainingSets(self):
        """
        void
        TrainingSet::updateSubTrainingSets()

        create all the sub-training sets: one for each label

        each subset contains only the phrase for the given label 
        """
        return _xmm.TrainingSet_updateSubTrainingSets(self)


    def mean(self):
        """
        vector< float >
        TrainingSet::mean() const

        Compute the global mean of all data phrases along the time axis.

        global mean of all phrases (along time axis, full-size) 
        """
        return _xmm.TrainingSet_mean(self)


    def variance(self):
        """
        vector< float >
        TrainingSet::variance() const

        Compute the global variance of all data phrases along the time axis.

        global variance of all phrases (along time axis, full-size) 
        """
        return _xmm.TrainingSet_variance(self)


    def to_json(self):
        """
        JSONNode
        TrainingSet::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.TrainingSet_to_json(self)


    def from_json(self, root):
        """
        void
        TrainingSet::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.TrainingSet_from_json(self, root)

    __swig_setmethods__["phrases"] = _xmm.TrainingSet_phrases_set
    __swig_getmethods__["phrases"] = _xmm.TrainingSet_phrases_get
    if _newclass:
        phrases = _swig_property(_xmm.TrainingSet_phrases_get, _xmm.TrainingSet_phrases_set)
    __swig_setmethods__["phraseLabels"] = _xmm.TrainingSet_phraseLabels_set
    __swig_getmethods__["phraseLabels"] = _xmm.TrainingSet_phraseLabels_get
    if _newclass:
        phraseLabels = _swig_property(_xmm.TrainingSet_phraseLabels_get, _xmm.TrainingSet_phraseLabels_set)
    __swig_setmethods__["allLabels"] = _xmm.TrainingSet_allLabels_set
    __swig_getmethods__["allLabels"] = _xmm.TrainingSet_allLabels_get
    if _newclass:
        allLabels = _swig_property(_xmm.TrainingSet_allLabels_get, _xmm.TrainingSet_allLabels_set)
TrainingSet_swigregister = _xmm.TrainingSet_swigregister
TrainingSet_swigregister(TrainingSet)


_xmm.TRAINING_RUN_swigconstant(_xmm)
TRAINING_RUN = _xmm.TRAINING_RUN

_xmm.TRAINING_DONE_swigconstant(_xmm)
TRAINING_DONE = _xmm.TRAINING_DONE

_xmm.TRAINING_ERROR_swigconstant(_xmm)
TRAINING_ERROR = _xmm.TRAINING_ERROR

_xmm.TRAINING_ABORT_swigconstant(_xmm)
TRAINING_ABORT = _xmm.TRAINING_ABORT
class EMStopCriterion(_object):
    """
    Stop Criterion for the EM algorithm.

    C++ includes: probabilistic_model.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EMStopCriterion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EMStopCriterion, name)
    __repr__ = _swig_repr
    __swig_setmethods__["minSteps"] = _xmm.EMStopCriterion_minSteps_set
    __swig_getmethods__["minSteps"] = _xmm.EMStopCriterion_minSteps_get
    if _newclass:
        minSteps = _swig_property(_xmm.EMStopCriterion_minSteps_get, _xmm.EMStopCriterion_minSteps_set)
    __swig_setmethods__["maxSteps"] = _xmm.EMStopCriterion_maxSteps_set
    __swig_getmethods__["maxSteps"] = _xmm.EMStopCriterion_maxSteps_get
    if _newclass:
        maxSteps = _swig_property(_xmm.EMStopCriterion_maxSteps_get, _xmm.EMStopCriterion_maxSteps_set)
    __swig_setmethods__["percentChg"] = _xmm.EMStopCriterion_percentChg_set
    __swig_getmethods__["percentChg"] = _xmm.EMStopCriterion_percentChg_get
    if _newclass:
        percentChg = _swig_property(_xmm.EMStopCriterion_percentChg_get, _xmm.EMStopCriterion_percentChg_set)

    def __init__(self):
        """
        Stop Criterion for the EM algorithm.

        C++ includes: probabilistic_model.h 
        """
        this = _xmm.new_EMStopCriterion()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_EMStopCriterion
    __del__ = lambda self: None
EMStopCriterion_swigregister = _xmm.EMStopCriterion_swigregister
EMStopCriterion_swigregister(EMStopCriterion)
EM_MODEL_DEFAULT_EMSTOP_MINSTEPS = cvar.EM_MODEL_DEFAULT_EMSTOP_MINSTEPS
EM_MODEL_DEFAULT_EMSTOP_MAXSTEPS = cvar.EM_MODEL_DEFAULT_EMSTOP_MAXSTEPS
EM_MODEL_DEFAULT_EMSTOP_PERCENT_CHG = cvar.EM_MODEL_DEFAULT_EMSTOP_PERCENT_CHG
EM_MODEL_DEFAULT_LIKELIHOOD_WINDOW = cvar.EM_MODEL_DEFAULT_LIKELIHOOD_WINDOW
EM_MODEL_DEFAULT_EMSTOP_ABSOLUTEMAXSTEPS = cvar.EM_MODEL_DEFAULT_EMSTOP_ABSOLUTEMAXSTEPS

class ProbabilisticModel(Listener, Writable):
    """
    Generic Template for Machine Learning Probabilistic models based on
    the EM algorithm.

    C++ includes: probabilistic_model.h 
    """
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProbabilisticModel, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProbabilisticModel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _xmm.delete_ProbabilisticModel
    __del__ = lambda self: None

    def is_training(self):
        """
        bool
        ProbabilisticModel::is_training() const

        Checks if the model is training.

        true if the model is training 
        """
        return _xmm.ProbabilisticModel_is_training(self)


    def set_trainingSet(self, trainingSet):
        """
        void
        ProbabilisticModel::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the dimensions of the model

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.ProbabilisticModel_set_trainingSet(self, trainingSet)


    def dimension(self):
        """
        unsigned int
        ProbabilisticModel::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm.ProbabilisticModel_dimension(self)


    def dimension_input(self):
        """
        unsigned
        int ProbabilisticModel::dimension_input() const

        Get the dimension of the input modality.

        WARNING:  This can only be used in bimodal mode (construction with
        'BIMODAL' flag)

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if not in bimodal mode 
        """
        return _xmm.ProbabilisticModel_dimension_input(self)


    def get_likelihoodwindow(self):
        """
        unsigned int ProbabilisticModel::get_likelihoodwindow() const

        get size of the likelihood smoothing buffer (number of frames)

        size of the likelihood smoothing buffer 
        """
        return _xmm.ProbabilisticModel_get_likelihoodwindow(self)


    def set_likelihoodwindow(self, likelihoodwindow):
        """
        void
        ProbabilisticModel::set_likelihoodwindow(unsigned int
        likelihoodwindow)

        set size of the likelihood smoothing buffer (number of frames)

        Parameters:
        -----------

        likelihoodwindow:  size of the likelihood smoothing buffer

        Exceptions:
        -----------

        invalid_argument:  if likelihoodwindow is < 1 
        """
        return _xmm.ProbabilisticModel_set_likelihoodwindow(self, likelihoodwindow)


    def train(self):
        """
        void
        ProbabilisticModel::train()

        Main training method based on the EM algorithm.

        the method performs a loop over the pure virtual method
        train_EM_update() until convergence. The train_EM_update method
        computes both E and M steps of the EM algorithm. See:  train_EM_update

        """
        return _xmm.ProbabilisticModel_train(self)


    def set_trainingCallback(self, callback, extradata):
        """
        void
        ProbabilisticModel::set_trainingCallback(void(*callback)(void
        *srcModel, CALLBACK_FLAG state, void *extradata), void *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm.ProbabilisticModel_set_trainingCallback(self, callback, extradata)

    __swig_getmethods__["train_func"] = lambda x: _xmm.ProbabilisticModel_train_func
    if _newclass:
        train_func = staticmethod(_xmm.ProbabilisticModel_train_func)

    def performance_init(self):
        """
        void
        ProbabilisticModel::performance_init()

        Initialize the 'Performance' phase: prepare model for performance. 
        """
        return _xmm.ProbabilisticModel_performance_init(self)


    def performance_update(self, observation):
        """
        virtual double ProbabilisticModel::performance_update(vector< float >
        const &observation)=0

        Main Play function: updates the predictions of the model given a new
        observation.

        Parameters:
        -----------

        observation:  observation vector (must be of size 'dimension' or
        'dimension_input' depending on the mode [unimodal/bimodal])

        likelihood of the observation 
        """
        return _xmm.ProbabilisticModel_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        ProbabilisticModel::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.ProbabilisticModel_to_json(self)


    def from_json(self, root):
        """
        void
        ProbabilisticModel::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.ProbabilisticModel_from_json(self, root)

    __swig_setmethods__["trainingSet"] = _xmm.ProbabilisticModel_trainingSet_set
    __swig_getmethods__["trainingSet"] = _xmm.ProbabilisticModel_trainingSet_get
    if _newclass:
        trainingSet = _swig_property(_xmm.ProbabilisticModel_trainingSet_get, _xmm.ProbabilisticModel_trainingSet_set)
    __swig_setmethods__["trained"] = _xmm.ProbabilisticModel_trained_set
    __swig_getmethods__["trained"] = _xmm.ProbabilisticModel_trained_get
    if _newclass:
        trained = _swig_property(_xmm.ProbabilisticModel_trained_get, _xmm.ProbabilisticModel_trained_set)
    __swig_setmethods__["stopcriterion"] = _xmm.ProbabilisticModel_stopcriterion_set
    __swig_getmethods__["stopcriterion"] = _xmm.ProbabilisticModel_stopcriterion_get
    if _newclass:
        stopcriterion = _swig_property(_xmm.ProbabilisticModel_stopcriterion_get, _xmm.ProbabilisticModel_stopcriterion_set)
    __swig_setmethods__["trainingProgression"] = _xmm.ProbabilisticModel_trainingProgression_set
    __swig_getmethods__["trainingProgression"] = _xmm.ProbabilisticModel_trainingProgression_get
    if _newclass:
        trainingProgression = _swig_property(_xmm.ProbabilisticModel_trainingProgression_get, _xmm.ProbabilisticModel_trainingProgression_set)
    __swig_setmethods__["results_instant_likelihood"] = _xmm.ProbabilisticModel_results_instant_likelihood_set
    __swig_getmethods__["results_instant_likelihood"] = _xmm.ProbabilisticModel_results_instant_likelihood_get
    if _newclass:
        results_instant_likelihood = _swig_property(_xmm.ProbabilisticModel_results_instant_likelihood_get, _xmm.ProbabilisticModel_results_instant_likelihood_set)
    __swig_setmethods__["results_log_likelihood"] = _xmm.ProbabilisticModel_results_log_likelihood_set
    __swig_getmethods__["results_log_likelihood"] = _xmm.ProbabilisticModel_results_log_likelihood_get
    if _newclass:
        results_log_likelihood = _swig_property(_xmm.ProbabilisticModel_results_log_likelihood_get, _xmm.ProbabilisticModel_results_log_likelihood_set)
    __swig_setmethods__["results_predicted_output"] = _xmm.ProbabilisticModel_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm.ProbabilisticModel_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm.ProbabilisticModel_results_predicted_output_get, _xmm.ProbabilisticModel_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm.ProbabilisticModel_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm.ProbabilisticModel_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm.ProbabilisticModel_results_output_variance_get, _xmm.ProbabilisticModel_results_output_variance_set)
    __swig_setmethods__["trainingLogLikelihood"] = _xmm.ProbabilisticModel_trainingLogLikelihood_set
    __swig_getmethods__["trainingLogLikelihood"] = _xmm.ProbabilisticModel_trainingLogLikelihood_get
    if _newclass:
        trainingLogLikelihood = _swig_property(_xmm.ProbabilisticModel_trainingLogLikelihood_get, _xmm.ProbabilisticModel_trainingLogLikelihood_set)
    __swig_setmethods__["trainingNbIterations"] = _xmm.ProbabilisticModel_trainingNbIterations_set
    __swig_getmethods__["trainingNbIterations"] = _xmm.ProbabilisticModel_trainingNbIterations_get
    if _newclass:
        trainingNbIterations = _swig_property(_xmm.ProbabilisticModel_trainingNbIterations_get, _xmm.ProbabilisticModel_trainingNbIterations_set)
ProbabilisticModel_swigregister = _xmm.ProbabilisticModel_swigregister
ProbabilisticModel_swigregister(ProbabilisticModel)

def ProbabilisticModel_train_func(context):
    return _xmm.ProbabilisticModel_train_func(context)
ProbabilisticModel_train_func = _xmm.ProbabilisticModel_train_func

class t_ellipse(_object):
    """
    Simple structure for storing Ellipse parameters.

    C++ includes: gaussian_distribution.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, t_ellipse, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, t_ellipse, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _xmm.t_ellipse_x_set
    __swig_getmethods__["x"] = _xmm.t_ellipse_x_get
    if _newclass:
        x = _swig_property(_xmm.t_ellipse_x_get, _xmm.t_ellipse_x_set)
    __swig_setmethods__["y"] = _xmm.t_ellipse_y_set
    __swig_getmethods__["y"] = _xmm.t_ellipse_y_get
    if _newclass:
        y = _swig_property(_xmm.t_ellipse_y_get, _xmm.t_ellipse_y_set)
    __swig_setmethods__["width"] = _xmm.t_ellipse_width_set
    __swig_getmethods__["width"] = _xmm.t_ellipse_width_get
    if _newclass:
        width = _swig_property(_xmm.t_ellipse_width_get, _xmm.t_ellipse_width_set)
    __swig_setmethods__["height"] = _xmm.t_ellipse_height_set
    __swig_getmethods__["height"] = _xmm.t_ellipse_height_get
    if _newclass:
        height = _swig_property(_xmm.t_ellipse_height_get, _xmm.t_ellipse_height_set)
    __swig_setmethods__["angle"] = _xmm.t_ellipse_angle_set
    __swig_getmethods__["angle"] = _xmm.t_ellipse_angle_get
    if _newclass:
        angle = _swig_property(_xmm.t_ellipse_angle_get, _xmm.t_ellipse_angle_set)

    def __init__(self):
        """
        Simple structure for storing Ellipse parameters.

        C++ includes: gaussian_distribution.h 
        """
        this = _xmm.new_t_ellipse()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_t_ellipse
    __del__ = lambda self: None
t_ellipse_swigregister = _xmm.t_ellipse_swigregister
t_ellipse_swigregister(t_ellipse)
GAUSSIAN_DEFAULT_VARIANCE_OFFSET_RELATIVE = cvar.GAUSSIAN_DEFAULT_VARIANCE_OFFSET_RELATIVE
GAUSSIAN_DEFAULT_VARIANCE_OFFSET_ABSOLUTE = cvar.GAUSSIAN_DEFAULT_VARIANCE_OFFSET_ABSOLUTE
EPSILON_GAUSSIAN = cvar.EPSILON_GAUSSIAN

class GaussianDistribution(Writable):
    """
    Multivariate Gaussian Distribution.

    Full covariance, optionally multimodal with support for regression

    C++ includes: gaussian_distribution.h 
    """
    __swig_setmethods__ = {}
    for _s in [Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianDistribution, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        GaussianDistribution::GaussianDistribution(GaussianDistribution const
        &src)

        Copy constructor.

        Parameters:
        -----------

        src:  source distribution 
        """
        this = _xmm.new_GaussianDistribution(*args)
        try:
            self.this.append(this)
        except:
            self.this = this

    def _copy(self, dst, src):
        """
        void
        GaussianDistribution::_copy(GaussianDistribution *dst,
        GaussianDistribution const &src)

        Copy between 2 Gaussian Distributions.

        Parameters:
        -----------

        dst:  destination distribution

        src:  source distribution 
        """
        return _xmm.GaussianDistribution__copy(self, dst, src)

    __swig_destroy__ = _xmm.delete_GaussianDistribution
    __del__ = lambda self: None

    def dimension(self):
        """
        unsigned int
        GaussianDistribution::dimension() const

        Get Dimension of the distribution.

        dimension 
        """
        return _xmm.GaussianDistribution_dimension(self)


    def set_dimension(self, dimension):
        """
        void
        GaussianDistribution::set_dimension(unsigned int dimension)

        Set Dimension of the distribution. 
        """
        return _xmm.GaussianDistribution_set_dimension(self, dimension)


    def dimension_input(self):
        """
        unsigned int GaussianDistribution::dimension_input() const

        Get Dimension of the input modality.

        dimension 
        """
        return _xmm.GaussianDistribution_dimension_input(self)


    def set_dimension_input(self, dimension_input):
        """
        void GaussianDistribution::set_dimension_input(unsigned int
        dimension_input)

        Set Dimension of the input modality.

        Parameters:
        -----------

        dimension_input:  dimension of the input modality

        Exceptions:
        -----------

        out_of_range:  if the dimension is superior to the total dimension 
        """
        return _xmm.GaussianDistribution_set_dimension_input(self, dimension_input)


    def likelihood(self, observation):
        """
        double
        GaussianDistribution::likelihood(const float *observation) const

        Get Likelihood of a data vector.

        Parameters:
        -----------

        observation:  data observation (must be of size dimension)

        likelihood

        Exceptions:
        -----------

        runtime_error:  if the Covariance Matrix is not invertible 
        """
        return _xmm.GaussianDistribution_likelihood(self, observation)


    def likelihood_input(self, observation_input):
        """
        double
        GaussianDistribution::likelihood_input(const float *observation_input)
        const

        Get Likelihood of a data vector for input modality.

        Parameters:
        -----------

        observation_input:  observation (must be of size dimension_input)

        likelihood

        Exceptions:
        -----------

        runtime_error:  if the Covariance Matrix of the input modality is not
        invertible

        runtime_error:  if the model is not bimodal 
        """
        return _xmm.GaussianDistribution_likelihood_input(self, observation_input)


    def likelihood_bimodal(self, observation_input, observation_output):
        """
        double GaussianDistribution::likelihood_bimodal(const float
        *observation_input, const float *observation_output) const

        Get Likelihood of a data vector for bimodal mode.

        Parameters:
        -----------

        observation_input:  observation of the input modality

        observation_output:  observation of the output modality

        Exceptions:
        -----------

        runtime_error:  if the Covariance Matrix is not invertible

        runtime_error:  if the model is not bimodal

        likelihood 
        """
        return _xmm.GaussianDistribution_likelihood_bimodal(self, observation_input, observation_output)


    def regression(self, observation_input, predicted_output):
        """
        void
        GaussianDistribution::regression(vector< float > const
        &observation_input, vector< float > &predicted_output) const

        Linear Regression using the Gaussian Distribution (covariance-based)

        Parameters:
        -----------

        observation_input:  input observation (must be of size:
        dimension_input)

        predicted_output:  predicted output vector (size: dimension-
        dimension_input)

        Exceptions:
        -----------

        runtime_error:  if the model is not bimodal 
        """
        return _xmm.GaussianDistribution_regression(self, observation_input, predicted_output)


    def to_json(self):
        """
        JSONNode
        GaussianDistribution::to_json() const

        Write to JSON Node.

        The JSON Node containing the Gaussian Distribution parameters 
        """
        return _xmm.GaussianDistribution_to_json(self)


    def from_json(self, root):
        """
        void
        GaussianDistribution::from_json(JSONNode root)

        Write to JSON Node.

        allocate model parameters and updates inverse Covariances

        Parameters:
        -----------

        root:  JSON Node containing model information and parameters

        Exceptions:
        -----------

        JSONException if the JSONNode has a wrong format 
        """
        return _xmm.GaussianDistribution_from_json(self, root)


    def allocate(self):
        """
        void
        GaussianDistribution::allocate()

        Resize Mean and Covariance Vectors to appropriate dimension. 
        """
        return _xmm.GaussianDistribution_allocate(self)


    def addOffset(self):
        """
        void
        GaussianDistribution::addOffset()

        Add offset to the diagonal of the covariance matrix.

        Ensures convergence + generalization on few examples 
        """
        return _xmm.GaussianDistribution_addOffset(self)


    def updateInverseCovariance(self):
        """
        void GaussianDistribution::updateInverseCovariance()

        Compute inverse covariance matrix.

        Exceptions:
        -----------

        runtime_error:  if the covariance matrix is not invertible 
        """
        return _xmm.GaussianDistribution_updateInverseCovariance(self)


    def updateOutputVariances(self):
        """
        void GaussianDistribution::updateOutputVariances()

        Compute the conditional variance vector of the output modality
        (conditioned over the input).

        Exceptions:
        -----------

        runtime_error:  if the model is not bimodal 
        """
        return _xmm.GaussianDistribution_updateOutputVariances(self)


    def ellipse(self, dimension1, dimension2):
        """
        Ellipse
        GaussianDistribution::ellipse(unsigned int dimension1, unsigned int
        dimension2)

        Compute the 95% Confidence Interval ellipse of the Gaussian.

        the ellipse is 2D, and is therefore projected over 2 axes

        Parameters:
        -----------

        dimension1:  index of the first axis

        dimension2:  index of the second axis

        Exceptions:
        -----------

        out_of_range:  if the dimensions are out of bounds

        ellipse parameters 
        """
        return _xmm.GaussianDistribution_ellipse(self, dimension1, dimension2)

    __swig_setmethods__["mean"] = _xmm.GaussianDistribution_mean_set
    __swig_getmethods__["mean"] = _xmm.GaussianDistribution_mean_get
    if _newclass:
        mean = _swig_property(_xmm.GaussianDistribution_mean_get, _xmm.GaussianDistribution_mean_set)
    __swig_setmethods__["covariance"] = _xmm.GaussianDistribution_covariance_set
    __swig_getmethods__["covariance"] = _xmm.GaussianDistribution_covariance_get
    if _newclass:
        covariance = _swig_property(_xmm.GaussianDistribution_covariance_get, _xmm.GaussianDistribution_covariance_set)
    __swig_setmethods__["offset_relative"] = _xmm.GaussianDistribution_offset_relative_set
    __swig_getmethods__["offset_relative"] = _xmm.GaussianDistribution_offset_relative_get
    if _newclass:
        offset_relative = _swig_property(_xmm.GaussianDistribution_offset_relative_get, _xmm.GaussianDistribution_offset_relative_set)
    __swig_setmethods__["offset_absolute"] = _xmm.GaussianDistribution_offset_absolute_set
    __swig_getmethods__["offset_absolute"] = _xmm.GaussianDistribution_offset_absolute_get
    if _newclass:
        offset_absolute = _swig_property(_xmm.GaussianDistribution_offset_absolute_get, _xmm.GaussianDistribution_offset_absolute_set)
    __swig_setmethods__["scale"] = _xmm.GaussianDistribution_scale_set
    __swig_getmethods__["scale"] = _xmm.GaussianDistribution_scale_get
    if _newclass:
        scale = _swig_property(_xmm.GaussianDistribution_scale_get, _xmm.GaussianDistribution_scale_set)
    __swig_setmethods__["weight_regression"] = _xmm.GaussianDistribution_weight_regression_set
    __swig_getmethods__["weight_regression"] = _xmm.GaussianDistribution_weight_regression_get
    if _newclass:
        weight_regression = _swig_property(_xmm.GaussianDistribution_weight_regression_get, _xmm.GaussianDistribution_weight_regression_set)
    __swig_setmethods__["output_variance"] = _xmm.GaussianDistribution_output_variance_set
    __swig_getmethods__["output_variance"] = _xmm.GaussianDistribution_output_variance_get
    if _newclass:
        output_variance = _swig_property(_xmm.GaussianDistribution_output_variance_get, _xmm.GaussianDistribution_output_variance_set)
GaussianDistribution_swigregister = _xmm.GaussianDistribution_swigregister
GaussianDistribution_swigregister(GaussianDistribution)

class KMeans(Listener, Writable):
    """
    K-Means Clustering algorithm.

    C++ includes: kmeans.h 
    """
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeans, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeans, name)
    __repr__ = _swig_repr
    RANDOM = _xmm.KMeans_RANDOM
    BIASED = _xmm.KMeans_BIASED

    def __init__(self, *args):
        """
        KMeans::KMeans(KMeans const
        &src)

        Copy Constructor.

        Parameters:
        -----------

        src:  Source Model 
        """
        this = _xmm.new_KMeans(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_KMeans
    __del__ = lambda self: None

    def is_training(self):
        """
        bool
        KMeans::is_training() const

        Checks if the model is training.

        true if the model is training 
        """
        return _xmm.KMeans_is_training(self)


    def set_trainingSet(self, trainingSet):
        """
        void
        KMeans::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the dimensions of the model

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.KMeans_set_trainingSet(self, trainingSet)


    def dimension(self):
        """
        unsigned int
        KMeans::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm.KMeans_dimension(self)


    def get_nbClusters(self):
        """
        unsigned int
        KMeans::get_nbClusters()

        Get Number of Clusters.

        Number of Clusters 
        """
        return _xmm.KMeans_get_nbClusters(self)


    def set_nbClusters(self, nbClusters):
        """
        void
        KMeans::set_nbClusters(unsigned int nbClusters)

        Set Number of Clusters.

        Parameters:
        -----------

        nbClusters:  Number of Clusters 
        """
        return _xmm.KMeans_set_nbClusters(self, nbClusters)


    def get_training_maxIterations(self):
        """
        unsigned
        int KMeans::get_training_maxIterations() const

        Get Maximum number of training iterations.

        Maximum number of training iterations 
        """
        return _xmm.KMeans_get_training_maxIterations(self)


    def set_training_maxIterations(self, maxIterations):
        """
        void
        KMeans::set_training_maxIterations(unsigned int maxIterations)

        Set Maximum number of training iterations.

        Parameters:
        -----------

        maxIterations:  Maximum number of training iterations 
        """
        return _xmm.KMeans_set_training_maxIterations(self, maxIterations)


    def get_training_relativeDistanceThreshold(self):
        """
        unsigned int KMeans::get_training_relativeDistanceThreshold() const

        Get relative distance Threshold for training.

        relative distance Threshold for training 
        """
        return _xmm.KMeans_get_training_relativeDistanceThreshold(self)


    def set_training_relativeDistanceThreshold(self, threshold):
        """
        void KMeans::set_training_relativeDistanceThreshold(float threshold)

        Set relative distance Threshold for training.

        Parameters:
        -----------

        threshold:  relative distance Threshold for training 
        """
        return _xmm.KMeans_set_training_relativeDistanceThreshold(self, threshold)


    def train(self):
        """
        void KMeans::train()

        Main training method. 
        """
        return _xmm.KMeans_train(self)


    def randomizeClusters(self):
        """
        void
        KMeans::randomizeClusters()

        randomzie Cluster Centers (normalized width data variance) of the
        first phrase of the training set 
        """
        return _xmm.KMeans_randomizeClusters(self)


    def set_trainingCallback(self, callback, extradata):
        """
        void
        KMeans::set_trainingCallback(void(*callback)(void *srcModel,
        CALLBACK_FLAG state, void *extradata), void *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm.KMeans_set_trainingCallback(self, callback, extradata)


    def train_func(context):
        """
        void *
        KMeans::train_func(void *context)

        Function pointer for parallel training.

        Parameters:
        -----------

        context:  pointer to the object to train 
        """
        return _xmm.KMeans_train_func(context)

    if _newclass:
        train_func = staticmethod(train_func)
    __swig_getmethods__["train_func"] = lambda x: train_func

    def performance_init(self):
        """
        void
        KMeans::performance_init()

        Initialize the 'Performance' phase: prepare model for performance. 
        """
        return _xmm.KMeans_performance_init(self)


    def performance_update(self, observation):
        """
        void
        KMeans::performance_update(vector< float > const &observation)

        Main Performance function: updates the predictions of the model given
        a new observation.

        Parameters:
        -----------

        observation:  observation vector (must be of size 'dimension') 
        """
        return _xmm.KMeans_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode KMeans::to_json()
        const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.KMeans_to_json(self)


    def from_json(self, root):
        """
        void
        KMeans::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.KMeans_from_json(self, root)

    __swig_setmethods__["trainingSet"] = _xmm.KMeans_trainingSet_set
    __swig_getmethods__["trainingSet"] = _xmm.KMeans_trainingSet_get
    if _newclass:
        trainingSet = _swig_property(_xmm.KMeans_trainingSet_get, _xmm.KMeans_trainingSet_set)
    __swig_setmethods__["centers"] = _xmm.KMeans_centers_set
    __swig_getmethods__["centers"] = _xmm.KMeans_centers_get
    if _newclass:
        centers = _swig_property(_xmm.KMeans_centers_get, _xmm.KMeans_centers_set)
    __swig_setmethods__["trainingNbIterations"] = _xmm.KMeans_trainingNbIterations_set
    __swig_getmethods__["trainingNbIterations"] = _xmm.KMeans_trainingNbIterations_get
    if _newclass:
        trainingNbIterations = _swig_property(_xmm.KMeans_trainingNbIterations_get, _xmm.KMeans_trainingNbIterations_set)
    __swig_setmethods__["results_distances"] = _xmm.KMeans_results_distances_set
    __swig_getmethods__["results_distances"] = _xmm.KMeans_results_distances_get
    if _newclass:
        results_distances = _swig_property(_xmm.KMeans_results_distances_get, _xmm.KMeans_results_distances_set)
    __swig_setmethods__["results_likeliest"] = _xmm.KMeans_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm.KMeans_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm.KMeans_results_likeliest_get, _xmm.KMeans_results_likeliest_set)
    __swig_setmethods__["trainingInitType"] = _xmm.KMeans_trainingInitType_set
    __swig_getmethods__["trainingInitType"] = _xmm.KMeans_trainingInitType_get
    if _newclass:
        trainingInitType = _swig_property(_xmm.KMeans_trainingInitType_get, _xmm.KMeans_trainingInitType_set)
KMeans_swigregister = _xmm.KMeans_swigregister
KMeans_swigregister(KMeans)
KMEANS_DEFAULT_MAX_ITERATIONS = cvar.KMEANS_DEFAULT_MAX_ITERATIONS
KMEANS_DEFAULT_RELATIVE_VARIATION_THRESHOLD = cvar.KMEANS_DEFAULT_RELATIVE_VARIATION_THRESHOLD

def KMeans_train_func(context):
    """
    void *
    KMeans::train_func(void *context)

    Function pointer for parallel training.

    Parameters:
    -----------

    context:  pointer to the object to train 
    """
    return _xmm.KMeans_train_func(context)

class GMM(ProbabilisticModel):
    """
    Gaussian Mixture Models.

    Multivariate Gaussian Mixture Model. Supports Bimodal data and
    Gaussian Mixture Regression. Can be either autonomous or a state of a
    HMM: defines observation probabilities for each state.

    C++ includes: gmm.h 
    """
    __swig_setmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        GMM::GMM(GMM const &src)

        Copy constructor.

        Parameters:
        -----------

        src:  Source GMM 
        """
        this = _xmm.new_GMM(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_GMM
    __del__ = lambda self: None

    def get_nbMixtureComponents(self):
        """
        int
        GMM::get_nbMixtureComponents() const

        Get the number of Gaussian mixture Components.

        number of Gaussian mixture components 
        """
        return _xmm.GMM_get_nbMixtureComponents(self)


    def get_varianceOffset_relative(self):
        """
        double
        GMM::get_varianceOffset_relative() const

        Get Offset added to covariance matrices for convergence.

        Offset added to covariance matrices for convergence (relative to data
        variance) 
        """
        return _xmm.GMM_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double
        GMM::get_varianceOffset_absolute() const

        Get Offset added to covariance matrices for convergence.

        Offset added to covariance matrices for convergence (minimum value) 
        """
        return _xmm.GMM_get_varianceOffset_absolute(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        GMM::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of mixture components of the model.

        WARNING:  sets the model to be untrained.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian Mixture Components

        Exceptions:
        -----------

        invalid_argument:  if nbMixtureComponents is <= 0 
        """
        return _xmm.GMM_set_nbMixtureComponents(self, nbMixtureComponents)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        GMM::set_varianceOffset(double varianceOffset_relative, double
        varianceOffset_absolute)

        Set the offset to add to the covariance matrices.

        Parameters:
        -----------

        varianceOffset_relative:  offset to add to the diagonal of covariance
        matrices (relative to data variance)

        varianceOffset_absolute:  offset to add to the diagonal of covariance
        matrices (minimum value)

        Exceptions:
        -----------

        invalid_argument:  if the covariance offset is <= 0 
        """
        return _xmm.GMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        GMM::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.GMM_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        GMM::set_weight_regression(double weight_regression)

        Get Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.GMM_set_weight_regression(self, weight_regression)


    def performance_init(self):
        """
        void
        GMM::performance_init()

        Initialize performance mode. 
        """
        return _xmm.GMM_performance_init(self)


    def performance_update(self, observation):
        """
        double
        GMM::performance_update(vector< float > const &observation)

        Main Play function: performs recognition (unimodal mode) or regression
        (bimodal mode)

        The predicted output is stored in the observation vector in bimodal
        mode

        Parameters:
        -----------

        observation:  observation (must allocated to size 'dimension')

        instantaneous likelihood 
        """
        return _xmm.GMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode GMM::to_json() const

        Write to JSON Node.

        JSON Node containing model information and parameters 
        """
        return _xmm.GMM_to_json(self)


    def from_json(self, root):
        """
        void GMM::from_json(JSONNode
        root)

        Read from JSON Node.

        allocate model parameters and updates inverse Covariances

        Parameters:
        -----------

        root:  JSON Node containing model information and parameters

        Exceptions:
        -----------

        JSONException if the JSONNode has a wrong format 
        """
        return _xmm.GMM_from_json(self, root)

    __swig_setmethods__["components"] = _xmm.GMM_components_set
    __swig_getmethods__["components"] = _xmm.GMM_components_get
    if _newclass:
        components = _swig_property(_xmm.GMM_components_get, _xmm.GMM_components_set)
    __swig_setmethods__["mixtureCoeffs"] = _xmm.GMM_mixtureCoeffs_set
    __swig_getmethods__["mixtureCoeffs"] = _xmm.GMM_mixtureCoeffs_get
    if _newclass:
        mixtureCoeffs = _swig_property(_xmm.GMM_mixtureCoeffs_get, _xmm.GMM_mixtureCoeffs_set)
    __swig_setmethods__["beta"] = _xmm.GMM_beta_set
    __swig_getmethods__["beta"] = _xmm.GMM_beta_get
    if _newclass:
        beta = _swig_property(_xmm.GMM_beta_get, _xmm.GMM_beta_set)
GMM_swigregister = _xmm.GMM_swigregister
GMM_swigregister(GMM)
GMM_DEFAULT_NB_MIXTURE_COMPONENTS = cvar.GMM_DEFAULT_NB_MIXTURE_COMPONENTS


_xmm.ERGODIC_swigconstant(_xmm)
ERGODIC = _xmm.ERGODIC

_xmm.LEFT_RIGHT_swigconstant(_xmm)
LEFT_RIGHT = _xmm.LEFT_RIGHT

_xmm.FULL_swigconstant(_xmm)
FULL = _xmm.FULL

_xmm.WINDOWED_swigconstant(_xmm)
WINDOWED = _xmm.WINDOWED

_xmm.LIKELIEST_swigconstant(_xmm)
LIKELIEST = _xmm.LIKELIEST
class HMM(ProbabilisticModel):
    """
    Hidden Markov Model.

    Support Hierarchical Model: if built with the flag 'HIERARCHICAL', the
    model includes exit transition probabilities. The model can be eith
    unimodal, or Multimodal when constructed with the flag 'BIMODAL'.

    C++ includes: hmm.h 
    """
    __swig_setmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [ProbabilisticModel]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        HMM::HMM(HMM const &src)

        Copy constructor.

        Parameters:
        -----------

        src:  Source Model 
        """
        this = _xmm.new_HMM(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_HMM
    __del__ = lambda self: None

    def set_trainingSet(self, trainingSet):
        """
        void
        HMM::set_trainingSet(TrainingSet *trainingSet)

        set the training set associated with the model

        updates the training sets of each GMM

        Parameters:
        -----------

        trainingSet:  pointer to the training set.

        Exceptions:
        -----------

        runtime_error:  if the training set has not the same number of
        modalities 
        """
        return _xmm.HMM_set_trainingSet(self, trainingSet)


    def get_nbStates(self):
        """
        int HMM::get_nbStates()
        const

        Get the Number of hidden states of the model.

        number of hidden states 
        """
        return _xmm.HMM_get_nbStates(self)


    def set_nbStates(self, nbStates):
        """
        void HMM::set_nbStates(int
        nbStates)

        Set the number of hidden states of the model.

        sets the mode to be untrained

        Parameters:
        -----------

        nbStates:  number of hidden states

        Exceptions:
        -----------

        invalid_argument:  if the number of states is <= 0 
        """
        return _xmm.HMM_set_nbStates(self, nbStates)


    def get_nbMixtureComponents(self):
        """
        int
        HMM::get_nbMixtureComponents() const

        Get the number of Gaussian mixture components of the observation
        probability distribution.

        number of Gaussian mixture components 
        """
        return _xmm.HMM_get_nbMixtureComponents(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        HMM::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of Gaussian mixture components of the observation
        probability distribution.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian mixture components

        Exceptions:
        -----------

        invalid_argument:  if the number of Gaussian mixture components is <=
        0 
        """
        return _xmm.HMM_set_nbMixtureComponents(self, nbMixtureComponents)


    def get_varianceOffset_relative(self):
        """
        double
        HMM::get_varianceOffset_relative() const

        Get the offset added to the diagonal of covariance matrices for
        convergence.

        offset added to the diagonal of covariance matrices (relative to data
        variance) 
        """
        return _xmm.HMM_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double
        HMM::get_varianceOffset_absolute() const

        Get the offset added to the diagonal of covariance matrices for
        convergence.

        offset added to the diagonal of covariance matrices (minimum value) 
        """
        return _xmm.HMM_get_varianceOffset_absolute(self)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        HMM::set_varianceOffset(double varianceOffset_relative, double
        varianceOffset_absolute)

        Get the offset added to the diagonal of covariance matrices for
        convergence.

        Parameters:
        -----------

        varianceOffset_relative:  offset added to the diagonal of covariances
        matrices (relative to data variance)

        varianceOffset_absolute:  offset added to the diagonal of covariances
        matrices (minimum value) 
        """
        return _xmm.HMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        HMM::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.HMM_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        HMM::set_weight_regression(double weight_regression)

        Set Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.HMM_set_weight_regression(self, weight_regression)


    def get_regression_estimator(self):
        """
        REGRESSION_ESTIMATOR HMM::get_regression_estimator() const

        Get the regression estimator type.

        regression estimator type

        See:  REGRESSION_ESTIMATOR 
        """
        return _xmm.HMM_get_regression_estimator(self)


    def set_regression_estimator(self, regression_estimator):
        """
        void
        HMM::set_regression_estimator(REGRESSION_ESTIMATOR
        regression_estimator)

        Set the regression estimator type.

        Parameters:
        -----------

        regression_estimator:  type of estimator

        See:  REGRESSION_ESTIMATOR 
        """
        return _xmm.HMM_set_regression_estimator(self, regression_estimator)


    def get_transitionMode(self):
        """
        string
        HMM::get_transitionMode() const

        get transition mode of the hidden Markov Chain

        string corresponding to the transition mode (left-right / ergodic) 
        """
        return _xmm.HMM_get_transitionMode(self)


    def set_transitionMode(self, transMode_str):
        """
        void
        HMM::set_transitionMode(string transMode_str)

        set transition mode of the hidden Markov Chain

        Parameters:
        -----------

        transMode_str:  string keyword corresponding to the transition mode
        ("left-right" / "ergodic")

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "left-right" or
        "ergodic" 
        """
        return _xmm.HMM_set_transitionMode(self, transMode_str)


    def addExitPoint(self, stateIndex, proba):
        """
        void HMM::addExitPoint(int
        stateIndex, float proba)

        Set the exit probability of a specific state.

        this method is only active in 'HIERARCHICAL' mode. The probability

        Parameters:
        -----------

        stateIndex:  index of the state to add the exit point

        proba:  probability to exit the gesture from this state

        Exceptions:
        -----------

        runtime_error:  if the model is not hierarchical

        out_of_range:  if the state index is out of bounds 
        """
        return _xmm.HMM_addExitPoint(self, stateIndex, proba)


    def performance_init(self):
        """
        void
        HMM::performance_init()

        Initialize the 'Performance' phase. 
        """
        return _xmm.HMM_performance_init(self)


    def performance_update(self, observation):
        """
        double
        HMM::performance_update(vector< float > const &observation)

        Main Play function: performs recognition (unimodal mode) or regression
        (bimodal mode)

        The predicted output is stored in the observation vector in bimodal
        mode

        Parameters:
        -----------

        observation:  pointer to current observation vector. Must be of size
        'dimension' (input + output dimension).

        likelihood computed on the gesture modality by a forward algorithm 
        """
        return _xmm.HMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode HMM::to_json() const

        Write to JSON Node.

        JSON Node containing model information and parameters 
        """
        return _xmm.HMM_to_json(self)


    def from_json(self, root):
        """
        void HMM::from_json(JSONNode
        root)

        Read from JSON Node.

        allocate model parameters and updates inverse Covariances

        Parameters:
        -----------

        root:  JSON Node containing model information and parameters

        Exceptions:
        -----------

        JSONException if the JSONNode has a wrong format 
        """
        return _xmm.HMM_from_json(self, root)

    __swig_setmethods__["results_progress"] = _xmm.HMM_results_progress_set
    __swig_getmethods__["results_progress"] = _xmm.HMM_results_progress_get
    if _newclass:
        results_progress = _swig_property(_xmm.HMM_results_progress_get, _xmm.HMM_results_progress_set)
    __swig_setmethods__["results_exit_likelihood"] = _xmm.HMM_results_exit_likelihood_set
    __swig_getmethods__["results_exit_likelihood"] = _xmm.HMM_results_exit_likelihood_get
    if _newclass:
        results_exit_likelihood = _swig_property(_xmm.HMM_results_exit_likelihood_get, _xmm.HMM_results_exit_likelihood_set)
    __swig_setmethods__["results_exit_ratio"] = _xmm.HMM_results_exit_ratio_set
    __swig_getmethods__["results_exit_ratio"] = _xmm.HMM_results_exit_ratio_get
    if _newclass:
        results_exit_ratio = _swig_property(_xmm.HMM_results_exit_ratio_get, _xmm.HMM_results_exit_ratio_set)
    __swig_setmethods__["results_likeliest_state"] = _xmm.HMM_results_likeliest_state_set
    __swig_getmethods__["results_likeliest_state"] = _xmm.HMM_results_likeliest_state_get
    if _newclass:
        results_likeliest_state = _swig_property(_xmm.HMM_results_likeliest_state_get, _xmm.HMM_results_likeliest_state_set)
    __swig_setmethods__["alpha"] = _xmm.HMM_alpha_set
    __swig_getmethods__["alpha"] = _xmm.HMM_alpha_get
    if _newclass:
        alpha = _swig_property(_xmm.HMM_alpha_get, _xmm.HMM_alpha_set)
    __swig_setmethods__["alpha_h"] = _xmm.HMM_alpha_h_set
    __swig_getmethods__["alpha_h"] = _xmm.HMM_alpha_h_get
    if _newclass:
        alpha_h = _swig_property(_xmm.HMM_alpha_h_get, _xmm.HMM_alpha_h_set)
    __swig_setmethods__["states_"] = _xmm.HMM_states__set
    __swig_getmethods__["states_"] = _xmm.HMM_states__get
    if _newclass:
        states_ = _swig_property(_xmm.HMM_states__get, _xmm.HMM_states__set)
HMM_swigregister = _xmm.HMM_swigregister
HMM_swigregister(HMM)
HMM_DEFAULT_NB_STATES = cvar.HMM_DEFAULT_NB_STATES
HMM_DEFAULT_ESTIMATEMEANS = cvar.HMM_DEFAULT_ESTIMATEMEANS
PLAY_EM_MAX_LOG_LIK_PERCENT_CHG = cvar.PLAY_EM_MAX_LOG_LIK_PERCENT_CHG
PLAY_EM_STEPS = cvar.PLAY_EM_STEPS
HMM_DEFAULT_EXITPROBABILITY_LAST_STATE = cvar.HMM_DEFAULT_EXITPROBABILITY_LAST_STATE
HMM_TRANSITION_REGULARIZATION = cvar.HMM_TRANSITION_REGULARIZATION

class _MODELGROUP_GMM(Listener, Writable):
    """
    Handle machine learning models running in parallel.

    templateparam:

    ModelType:  type of the models (implemented: GMM, HMM)

    C++ includes: model_group.h 
    """
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MODELGROUP_GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _MODELGROUP_GMM, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LIKELIEST = _xmm._MODELGROUP_GMM_LIKELIEST
    MIXTURE = _xmm._MODELGROUP_GMM_MIXTURE
    __swig_destroy__ = _xmm.delete__MODELGROUP_GMM
    __del__ = lambda self: None

    def is_training(self):
        """
        bool ModelGroup<
        ModelType >::is_training() const

        Check if at least 1 model is still training.

        true if at least 1 model is still training 
        """
        return _xmm._MODELGROUP_GMM_is_training(self)


    def is_trained(self, *args):
        """
        bool ModelGroup<
        ModelType >::is_trained() const

        Check if all models have been trained.

        true if all the models has been trained and the training data has not
        been modified in between 
        """
        return _xmm._MODELGROUP_GMM_is_trained(self, *args)


    def size(self):
        """
        unsigned int ModelGroup<
        ModelType >::size() const

        get the number of models

        number of models 
        """
        return _xmm._MODELGROUP_GMM_size(self)


    def clear(self):
        """
        virtual void ModelGroup<
        ModelType >::clear()

        Remove All models. 
        """
        return _xmm._MODELGROUP_GMM_clear(self)


    def remove(self, label):
        """
        virtual void ModelGroup<
        ModelType >::remove(Label const &label)

        Remove Specific model.

        Parameters:
        -----------

        label:  label of the model

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm._MODELGROUP_GMM_remove(self, label)


    def set_trainingSet(self, globalTrainingSet):
        """
        void ModelGroup<
        ModelType >::set_trainingSet(TrainingSet *globalTrainingSet)

        Set pointer to the global training set.

        Parameters:
        -----------

        globalTrainingSet:  pointer to the global training set 
        """
        return _xmm._MODELGROUP_GMM_set_trainingSet(self, globalTrainingSet)


    def dimension(self):
        """
        int ModelGroup<
        ModelType >::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm._MODELGROUP_GMM_dimension(self)


    def dimension_input(self):
        """
        int ModelGroup<
        ModelType >::dimension_input() const

        Get the dimension of the input modality.

        WARNING:  This can only be used in bimodal mode (construction with
        'BIMODAL' flag)

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if not in bimodal mode 
        """
        return _xmm._MODELGROUP_GMM_dimension_input(self)


    def set_performanceMode(self, performanceMode_str):
        """
        void
        ModelGroup< ModelType >::set_performanceMode(string
        performanceMode_str)

        Sets the performance mode (likeliest vs mixture)

        Parameters:
        -----------

        performanceMode_str:  performance mode: if "likeliest", the
        performance_update function estimates the output modality with the
        likeliest model. If "mixture", the performance_update function
        estimates the output modality as a weighted sum of all models'
        predictions.

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "likeliest" or "mixture"

        """
        return _xmm._MODELGROUP_GMM_set_performanceMode(self, performanceMode_str)


    def get_performanceMode(self):
        """
        string
        ModelGroup< ModelType >::get_performanceMode()

        Get the performance mode (likeliest vs mixture)

        performance mode: if "likeliest", the performance_update function
        estimates the output modality with the likeliest model. If
        "mixture", the performance_update function estimates the output
        modality as a weighted sum of all models' predictions. 
        """
        return _xmm._MODELGROUP_GMM_get_performanceMode(self)


    def get_EM_minSteps(self):
        """
        unsigned int
        ModelGroup< ModelType >::get_EM_minSteps() const

        Get minimum number of EM steps.

        minimum number of steps of the EM algorithm 
        """
        return _xmm._MODELGROUP_GMM_get_EM_minSteps(self)


    def get_EM_maxSteps(self):
        """
        unsigned int
        ModelGroup< ModelType >::get_EM_maxSteps() const

        Get maximum number of EM steps.

        maximum number of steps of the EM algorithm

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_GMM_get_EM_maxSteps(self)


    def get_EM_percentChange(self):
        """
        double
        ModelGroup< ModelType >::get_EM_percentChange() const

        Get EM convergence threshold in percent-change of the likelihood.

        loglikelihood percent-change convergence threshold

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_GMM_get_EM_percentChange(self)


    def set_EM_minSteps(self, steps):
        """
        void ModelGroup<
        ModelType >::set_EM_minSteps(unsigned int steps)

        Set minimum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  minimum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_GMM_set_EM_minSteps(self, steps)


    def set_EM_maxSteps(self, steps):
        """
        void ModelGroup<
        ModelType >::set_EM_maxSteps(unsigned int steps)

        Set maximum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  maximum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_GMM_set_EM_maxSteps(self, steps)


    def set_EM_percentChange(self, logLikPercentChg_):
        """
        void
        ModelGroup< ModelType >::set_EM_percentChange(double
        logLikPercentChg_)

        Set convergence threshold in percent-change of the likelihood.

        Parameters:
        -----------

        logLikPercentChg_:  log-likelihood percent-change convergence
        threshold

        Exceptions:
        -----------

        invalid_argument:  if logLikelihoodPercentChg <= 0 
        """
        return _xmm._MODELGROUP_GMM_set_EM_percentChange(self, logLikPercentChg_)


    def get_likelihoodwindow(self):
        """
        unsigned int
        ModelGroup< ModelType >::get_likelihoodwindow() const

        get size of the likelihood smoothing buffer (number of frames)

        size of the likelihood smoothing buffer 
        """
        return _xmm._MODELGROUP_GMM_get_likelihoodwindow(self)


    def set_likelihoodwindow(self, likelihoodwindow):
        """
        void
        ModelGroup< ModelType >::set_likelihoodwindow(unsigned int
        likelihoodwindow)

        set size of the likelihood smoothing buffer (number of frames)

        Parameters:
        -----------

        likelihoodwindow:  size of the likelihood smoothing buffer

        Exceptions:
        -----------

        invalid_argument:  if likelihoodwindow is < 1 
        """
        return _xmm._MODELGROUP_GMM_set_likelihoodwindow(self, likelihoodwindow)


    def train(self, *args):
        """
        virtual void ModelGroup<
        ModelType >::train()

        Train All model even if their data have not changed. 
        """
        return _xmm._MODELGROUP_GMM_train(self, *args)


    def retrain(self):
        """
        virtual void ModelGroup<
        ModelType >::retrain()

        Train all model which data has changed. 
        """
        return _xmm._MODELGROUP_GMM_retrain(self)


    def monitor_training(model, state, extradata):
        """
        static void
        ModelGroup< ModelType >::monitor_training(void *model, CALLBACK_FLAG
        state, void *extradata)

        Monitors the training of each model of the group. 
        """
        return _xmm._MODELGROUP_GMM_monitor_training(model, state, extradata)

    if _newclass:
        monitor_training = staticmethod(monitor_training)
    __swig_getmethods__["monitor_training"] = lambda x: monitor_training

    def set_trainingCallback(self, callback, extradata):
        """
        void
        ModelGroup< ModelType >::set_trainingCallback(void(*callback)(void
        *srcModel, CALLBACK_FLAG state, void *extradata), void *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm._MODELGROUP_GMM_set_trainingCallback(self, callback, extradata)


    def performance_init(self):
        """
        virtual void
        ModelGroup< ModelType >::performance_init()

        Initialize Performance. 
        """
        return _xmm._MODELGROUP_GMM_performance_init(self)


    def update_likelihood_results(self):
        """
        virtual
        void ModelGroup< ModelType >::update_likelihood_results()

        Update the results (Likelihoods) 
        """
        return _xmm._MODELGROUP_GMM_update_likelihood_results(self)

    __swig_setmethods__["models"] = _xmm._MODELGROUP_GMM_models_set
    __swig_getmethods__["models"] = _xmm._MODELGROUP_GMM_models_get
    if _newclass:
        models = _swig_property(_xmm._MODELGROUP_GMM_models_get, _xmm._MODELGROUP_GMM_models_set)
    __swig_setmethods__["globalTrainingSet"] = _xmm._MODELGROUP_GMM_globalTrainingSet_set
    __swig_getmethods__["globalTrainingSet"] = _xmm._MODELGROUP_GMM_globalTrainingSet_get
    if _newclass:
        globalTrainingSet = _swig_property(_xmm._MODELGROUP_GMM_globalTrainingSet_get, _xmm._MODELGROUP_GMM_globalTrainingSet_set)
    __swig_setmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_instant_likelihoods_set
    __swig_getmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_instant_likelihoods_get
    if _newclass:
        results_instant_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_instant_likelihoods_get, _xmm._MODELGROUP_GMM_results_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_set
    __swig_getmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_get
    if _newclass:
        results_normalized_instant_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_get, _xmm._MODELGROUP_GMM_results_normalized_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_likelihoods_set
    __swig_getmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_GMM_results_normalized_likelihoods_get
    if _newclass:
        results_normalized_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_normalized_likelihoods_get, _xmm._MODELGROUP_GMM_results_normalized_likelihoods_set)
    __swig_setmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_GMM_results_log_likelihoods_set
    __swig_getmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_GMM_results_log_likelihoods_get
    if _newclass:
        results_log_likelihoods = _swig_property(_xmm._MODELGROUP_GMM_results_log_likelihoods_get, _xmm._MODELGROUP_GMM_results_log_likelihoods_set)
    __swig_setmethods__["results_likeliest"] = _xmm._MODELGROUP_GMM_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm._MODELGROUP_GMM_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm._MODELGROUP_GMM_results_likeliest_get, _xmm._MODELGROUP_GMM_results_likeliest_set)
    __swig_setmethods__["results_predicted_output"] = _xmm._MODELGROUP_GMM_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm._MODELGROUP_GMM_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm._MODELGROUP_GMM_results_predicted_output_get, _xmm._MODELGROUP_GMM_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm._MODELGROUP_GMM_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm._MODELGROUP_GMM_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm._MODELGROUP_GMM_results_output_variance_get, _xmm._MODELGROUP_GMM_results_output_variance_set)
_MODELGROUP_GMM_swigregister = _xmm._MODELGROUP_GMM_swigregister
_MODELGROUP_GMM_swigregister(_MODELGROUP_GMM)

def _MODELGROUP_GMM_monitor_training(model, state, extradata):
    """
    static void
    ModelGroup< ModelType >::monitor_training(void *model, CALLBACK_FLAG
    state, void *extradata)

    Monitors the training of each model of the group. 
    """
    return _xmm._MODELGROUP_GMM_monitor_training(model, state, extradata)

class _MODELGROUP_HMM(Listener, Writable):
    """
    Handle machine learning models running in parallel.

    templateparam:

    ModelType:  type of the models (implemented: GMM, HMM)

    C++ includes: model_group.h 
    """
    __swig_setmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _MODELGROUP_HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Listener, Writable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _MODELGROUP_HMM, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LIKELIEST = _xmm._MODELGROUP_HMM_LIKELIEST
    MIXTURE = _xmm._MODELGROUP_HMM_MIXTURE
    __swig_destroy__ = _xmm.delete__MODELGROUP_HMM
    __del__ = lambda self: None

    def is_training(self):
        """
        bool ModelGroup<
        ModelType >::is_training() const

        Check if at least 1 model is still training.

        true if at least 1 model is still training 
        """
        return _xmm._MODELGROUP_HMM_is_training(self)


    def is_trained(self, *args):
        """
        bool ModelGroup<
        ModelType >::is_trained() const

        Check if all models have been trained.

        true if all the models has been trained and the training data has not
        been modified in between 
        """
        return _xmm._MODELGROUP_HMM_is_trained(self, *args)


    def size(self):
        """
        unsigned int ModelGroup<
        ModelType >::size() const

        get the number of models

        number of models 
        """
        return _xmm._MODELGROUP_HMM_size(self)


    def clear(self):
        """
        virtual void ModelGroup<
        ModelType >::clear()

        Remove All models. 
        """
        return _xmm._MODELGROUP_HMM_clear(self)


    def remove(self, label):
        """
        virtual void ModelGroup<
        ModelType >::remove(Label const &label)

        Remove Specific model.

        Parameters:
        -----------

        label:  label of the model

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm._MODELGROUP_HMM_remove(self, label)


    def set_trainingSet(self, globalTrainingSet):
        """
        void ModelGroup<
        ModelType >::set_trainingSet(TrainingSet *globalTrainingSet)

        Set pointer to the global training set.

        Parameters:
        -----------

        globalTrainingSet:  pointer to the global training set 
        """
        return _xmm._MODELGROUP_HMM_set_trainingSet(self, globalTrainingSet)


    def dimension(self):
        """
        int ModelGroup<
        ModelType >::dimension() const

        Get Total Dimension of the model (sum of dimension of modalities)

        total dimension of Gaussian Distributions 
        """
        return _xmm._MODELGROUP_HMM_dimension(self)


    def dimension_input(self):
        """
        int ModelGroup<
        ModelType >::dimension_input() const

        Get the dimension of the input modality.

        WARNING:  This can only be used in bimodal mode (construction with
        'BIMODAL' flag)

        dimension of the input modality

        Exceptions:
        -----------

        runtime_error:  if not in bimodal mode 
        """
        return _xmm._MODELGROUP_HMM_dimension_input(self)


    def set_performanceMode(self, performanceMode_str):
        """
        void
        ModelGroup< ModelType >::set_performanceMode(string
        performanceMode_str)

        Sets the performance mode (likeliest vs mixture)

        Parameters:
        -----------

        performanceMode_str:  performance mode: if "likeliest", the
        performance_update function estimates the output modality with the
        likeliest model. If "mixture", the performance_update function
        estimates the output modality as a weighted sum of all models'
        predictions.

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "likeliest" or "mixture"

        """
        return _xmm._MODELGROUP_HMM_set_performanceMode(self, performanceMode_str)


    def get_performanceMode(self):
        """
        string
        ModelGroup< ModelType >::get_performanceMode()

        Get the performance mode (likeliest vs mixture)

        performance mode: if "likeliest", the performance_update function
        estimates the output modality with the likeliest model. If
        "mixture", the performance_update function estimates the output
        modality as a weighted sum of all models' predictions. 
        """
        return _xmm._MODELGROUP_HMM_get_performanceMode(self)


    def get_EM_minSteps(self):
        """
        unsigned int
        ModelGroup< ModelType >::get_EM_minSteps() const

        Get minimum number of EM steps.

        minimum number of steps of the EM algorithm 
        """
        return _xmm._MODELGROUP_HMM_get_EM_minSteps(self)


    def get_EM_maxSteps(self):
        """
        unsigned int
        ModelGroup< ModelType >::get_EM_maxSteps() const

        Get maximum number of EM steps.

        maximum number of steps of the EM algorithm

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_HMM_get_EM_maxSteps(self)


    def get_EM_percentChange(self):
        """
        double
        ModelGroup< ModelType >::get_EM_percentChange() const

        Get EM convergence threshold in percent-change of the likelihood.

        loglikelihood percent-change convergence threshold

        See:  EMStopCriterion 
        """
        return _xmm._MODELGROUP_HMM_get_EM_percentChange(self)


    def set_EM_minSteps(self, steps):
        """
        void ModelGroup<
        ModelType >::set_EM_minSteps(unsigned int steps)

        Set minimum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  minimum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_HMM_set_EM_minSteps(self, steps)


    def set_EM_maxSteps(self, steps):
        """
        void ModelGroup<
        ModelType >::set_EM_maxSteps(unsigned int steps)

        Set maximum number of steps of the EM algorithm.

        Parameters:
        -----------

        steps:  maximum number of steps of the EM algorithm

        Exceptions:
        -----------

        invalid_argument:  if steps < 1 
        """
        return _xmm._MODELGROUP_HMM_set_EM_maxSteps(self, steps)


    def set_EM_percentChange(self, logLikPercentChg_):
        """
        void
        ModelGroup< ModelType >::set_EM_percentChange(double
        logLikPercentChg_)

        Set convergence threshold in percent-change of the likelihood.

        Parameters:
        -----------

        logLikPercentChg_:  log-likelihood percent-change convergence
        threshold

        Exceptions:
        -----------

        invalid_argument:  if logLikelihoodPercentChg <= 0 
        """
        return _xmm._MODELGROUP_HMM_set_EM_percentChange(self, logLikPercentChg_)


    def get_likelihoodwindow(self):
        """
        unsigned int
        ModelGroup< ModelType >::get_likelihoodwindow() const

        get size of the likelihood smoothing buffer (number of frames)

        size of the likelihood smoothing buffer 
        """
        return _xmm._MODELGROUP_HMM_get_likelihoodwindow(self)


    def set_likelihoodwindow(self, likelihoodwindow):
        """
        void
        ModelGroup< ModelType >::set_likelihoodwindow(unsigned int
        likelihoodwindow)

        set size of the likelihood smoothing buffer (number of frames)

        Parameters:
        -----------

        likelihoodwindow:  size of the likelihood smoothing buffer

        Exceptions:
        -----------

        invalid_argument:  if likelihoodwindow is < 1 
        """
        return _xmm._MODELGROUP_HMM_set_likelihoodwindow(self, likelihoodwindow)


    def train(self, *args):
        """
        virtual void ModelGroup<
        ModelType >::train()

        Train All model even if their data have not changed. 
        """
        return _xmm._MODELGROUP_HMM_train(self, *args)


    def retrain(self):
        """
        virtual void ModelGroup<
        ModelType >::retrain()

        Train all model which data has changed. 
        """
        return _xmm._MODELGROUP_HMM_retrain(self)


    def monitor_training(model, state, extradata):
        """
        static void
        ModelGroup< ModelType >::monitor_training(void *model, CALLBACK_FLAG
        state, void *extradata)

        Monitors the training of each model of the group. 
        """
        return _xmm._MODELGROUP_HMM_monitor_training(model, state, extradata)

    if _newclass:
        monitor_training = staticmethod(monitor_training)
    __swig_getmethods__["monitor_training"] = lambda x: monitor_training

    def set_trainingCallback(self, callback, extradata):
        """
        void
        ModelGroup< ModelType >::set_trainingCallback(void(*callback)(void
        *srcModel, CALLBACK_FLAG state, void *extradata), void *extradata)

        set the callback function associated with the training algorithm

        the function is called whenever the training is over or an error
        happened during training 
        """
        return _xmm._MODELGROUP_HMM_set_trainingCallback(self, callback, extradata)


    def performance_init(self):
        """
        virtual void
        ModelGroup< ModelType >::performance_init()

        Initialize Performance. 
        """
        return _xmm._MODELGROUP_HMM_performance_init(self)


    def update_likelihood_results(self):
        """
        virtual
        void ModelGroup< ModelType >::update_likelihood_results()

        Update the results (Likelihoods) 
        """
        return _xmm._MODELGROUP_HMM_update_likelihood_results(self)

    __swig_setmethods__["models"] = _xmm._MODELGROUP_HMM_models_set
    __swig_getmethods__["models"] = _xmm._MODELGROUP_HMM_models_get
    if _newclass:
        models = _swig_property(_xmm._MODELGROUP_HMM_models_get, _xmm._MODELGROUP_HMM_models_set)
    __swig_setmethods__["globalTrainingSet"] = _xmm._MODELGROUP_HMM_globalTrainingSet_set
    __swig_getmethods__["globalTrainingSet"] = _xmm._MODELGROUP_HMM_globalTrainingSet_get
    if _newclass:
        globalTrainingSet = _swig_property(_xmm._MODELGROUP_HMM_globalTrainingSet_get, _xmm._MODELGROUP_HMM_globalTrainingSet_set)
    __swig_setmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_instant_likelihoods_set
    __swig_getmethods__["results_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_instant_likelihoods_get
    if _newclass:
        results_instant_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_instant_likelihoods_get, _xmm._MODELGROUP_HMM_results_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_set
    __swig_getmethods__["results_normalized_instant_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_get
    if _newclass:
        results_normalized_instant_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_get, _xmm._MODELGROUP_HMM_results_normalized_instant_likelihoods_set)
    __swig_setmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_likelihoods_set
    __swig_getmethods__["results_normalized_likelihoods"] = _xmm._MODELGROUP_HMM_results_normalized_likelihoods_get
    if _newclass:
        results_normalized_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_normalized_likelihoods_get, _xmm._MODELGROUP_HMM_results_normalized_likelihoods_set)
    __swig_setmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_HMM_results_log_likelihoods_set
    __swig_getmethods__["results_log_likelihoods"] = _xmm._MODELGROUP_HMM_results_log_likelihoods_get
    if _newclass:
        results_log_likelihoods = _swig_property(_xmm._MODELGROUP_HMM_results_log_likelihoods_get, _xmm._MODELGROUP_HMM_results_log_likelihoods_set)
    __swig_setmethods__["results_likeliest"] = _xmm._MODELGROUP_HMM_results_likeliest_set
    __swig_getmethods__["results_likeliest"] = _xmm._MODELGROUP_HMM_results_likeliest_get
    if _newclass:
        results_likeliest = _swig_property(_xmm._MODELGROUP_HMM_results_likeliest_get, _xmm._MODELGROUP_HMM_results_likeliest_set)
    __swig_setmethods__["results_predicted_output"] = _xmm._MODELGROUP_HMM_results_predicted_output_set
    __swig_getmethods__["results_predicted_output"] = _xmm._MODELGROUP_HMM_results_predicted_output_get
    if _newclass:
        results_predicted_output = _swig_property(_xmm._MODELGROUP_HMM_results_predicted_output_get, _xmm._MODELGROUP_HMM_results_predicted_output_set)
    __swig_setmethods__["results_output_variance"] = _xmm._MODELGROUP_HMM_results_output_variance_set
    __swig_getmethods__["results_output_variance"] = _xmm._MODELGROUP_HMM_results_output_variance_get
    if _newclass:
        results_output_variance = _swig_property(_xmm._MODELGROUP_HMM_results_output_variance_get, _xmm._MODELGROUP_HMM_results_output_variance_set)
_MODELGROUP_HMM_swigregister = _xmm._MODELGROUP_HMM_swigregister
_MODELGROUP_HMM_swigregister(_MODELGROUP_HMM)

def _MODELGROUP_HMM_monitor_training(model, state, extradata):
    """
    static void
    ModelGroup< ModelType >::monitor_training(void *model, CALLBACK_FLAG
    state, void *extradata)

    Monitors the training of each model of the group. 
    """
    return _xmm._MODELGROUP_HMM_monitor_training(model, state, extradata)

class GMMGroup(_MODELGROUP_GMM):
    """
    Set of GMMs Running in parallel.

    Allows to perform GMM-based pattern recognition. See:  ModelGroup

    C++ includes: gmm_group.h 
    """
    __swig_setmethods__ = {}
    for _s in [_MODELGROUP_GMM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMMGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [_MODELGROUP_GMM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMMGroup, name)
    __repr__ = _swig_repr

    def __init__(self, flags=NONE, globalTrainingSet=None):
        """
        GMMGroup::GMMGroup(rtml_flags flags=NONE, TrainingSet
        *globalTrainingSet=NULL)

        Constructor.

        Parameters:
        -----------

        globalTrainingSet:  training set associated with the model

        flags:  Construction Flags: use 'BIMODAL' for use with Gaussian
        Mixture Regression. 
        """
        this = _xmm.new_GMMGroup(flags, globalTrainingSet)
        try:
            self.this.append(this)
        except:
            self.this = this

    def get_nbMixtureComponents(self):
        """
        int
        GMMGroup::get_nbMixtureComponents() const

        Get the number of Gaussian mixture Components.

        number of Gaussian mixture components 
        """
        return _xmm.GMMGroup_get_nbMixtureComponents(self)


    def get_varianceOffset_relative(self):
        """
        double
        GMMGroup::get_varianceOffset_relative() const

        Get Offset added to covariance matrices for convergence (Relative to
        data variance)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.GMMGroup_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double
        GMMGroup::get_varianceOffset_absolute() const

        Get Offset added to covariance matrices for convergence (Minimum
        value)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.GMMGroup_get_varianceOffset_absolute(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        GMMGroup::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of mixture components of the model.

        WARNING:  sets the model to be untrained.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian Mixture Components

        Exceptions:
        -----------

        invalid_argument:  if nbMixtureComponents is <= 0 
        """
        return _xmm.GMMGroup_set_nbMixtureComponents(self, nbMixtureComponents)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        GMMGroup::set_varianceOffset(double varianceOffset_relative, double
        varianceOffset_absolute)

        Set the offset to add to the covariance matrices.

        Parameters:
        -----------

        varianceOffset_relative:  offset to add to the diagonal of covariance
        matrices (relative to data variance)

        varianceOffset_absolute:  offset to add to the diagonal of covariance
        matrices (minimum value)

        Exceptions:
        -----------

        invalid_argument:  if the covariance offset is <= 0 
        """
        return _xmm.GMMGroup_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        GMMGroup::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.GMMGroup_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        GMMGroup::set_weight_regression(double weight_regression)

        Get Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.GMMGroup_set_weight_regression(self, weight_regression)


    def performance_update(self, observation):
        """
        void
        GMMGroup::performance_update(vector< float > const &observation)

        Main Play function: performs recognition (unimodal mode) and
        regression (bimodal mode)

        The predicted output is stored in the observation vector in bimodal
        mode

        Parameters:
        -----------

        observation:  observation vector 
        """
        return _xmm.GMMGroup_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        GMMGroup::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.GMMGroup_to_json(self)


    def from_json(self, root):
        """
        void
        GMMGroup::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.GMMGroup_from_json(self, root)

    __swig_destroy__ = _xmm.delete_GMMGroup
    __del__ = lambda self: None
GMMGroup_swigregister = _xmm.GMMGroup_swigregister
GMMGroup_swigregister(GMMGroup)

class HierarchicalHMM(_MODELGROUP_HMM):
    """
    Hierarchical Hidden Markov Model.

    Todo Needs more details

    C++ includes: hierarchical_hmm.h 
    """
    __swig_setmethods__ = {}
    for _s in [_MODELGROUP_HMM]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HierarchicalHMM, name, value)
    __swig_getmethods__ = {}
    for _s in [_MODELGROUP_HMM]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HierarchicalHMM, name)
    __repr__ = _swig_repr

    def __init__(self, flags=NONE, _globalTrainingSet=None):
        """
        HierarchicalHMM::HierarchicalHMM(rtml_flags flags=NONE, TrainingSet
        *_globalTrainingSet=NULL) 
        """
        this = _xmm.new_HierarchicalHMM(flags, _globalTrainingSet)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _xmm.delete_HierarchicalHMM
    __del__ = lambda self: None

    def clear(self):
        """
        void
        HierarchicalHMM::clear()

        Remove All models. 
        """
        return _xmm.HierarchicalHMM_clear(self)


    def get_nbStates(self):
        """
        int
        HierarchicalHMM::get_nbStates() const

        Get the Number of hidden states of the model.

        number of hidden states 
        """
        return _xmm.HierarchicalHMM_get_nbStates(self)


    def set_nbStates(self, nbStates):
        """
        void
        HierarchicalHMM::set_nbStates(int nbStates)

        Set the number of hidden states of the model.

        sets the mode to be untrained

        Parameters:
        -----------

        nbStates:  number of hidden states

        Exceptions:
        -----------

        invalid_argument:  if the number of states is <= 0 
        """
        return _xmm.HierarchicalHMM_set_nbStates(self, nbStates)


    def get_nbMixtureComponents(self):
        """
        int
        HierarchicalHMM::get_nbMixtureComponents() const

        Get the number of Gaussian mixture components of the observation
        probability distribution.

        number of Gaussian mixture components 
        """
        return _xmm.HierarchicalHMM_get_nbMixtureComponents(self)


    def set_nbMixtureComponents(self, nbMixtureComponents):
        """
        void
        HierarchicalHMM::set_nbMixtureComponents(int nbMixtureComponents)

        Set the number of Gaussian mixture components of the observation
        probability distribution.

        Parameters:
        -----------

        nbMixtureComponents:  number of Gaussian mixture components

        Exceptions:
        -----------

        invalid_argument:  if the number of Gaussian mixture components is <=
        0 
        """
        return _xmm.HierarchicalHMM_set_nbMixtureComponents(self, nbMixtureComponents)


    def get_varianceOffset_relative(self):
        """
        double HierarchicalHMM::get_varianceOffset_relative() const

        Get Offset added to covariance matrices for convergence (Relative to
        data variance)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.HierarchicalHMM_get_varianceOffset_relative(self)


    def get_varianceOffset_absolute(self):
        """
        double HierarchicalHMM::get_varianceOffset_absolute() const

        Get Offset added to covariance matrices for convergence (Minimum
        value)

        Offset added to covariance matrices for convergence 
        """
        return _xmm.HierarchicalHMM_get_varianceOffset_absolute(self)


    def set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute):
        """
        void
        HierarchicalHMM::set_varianceOffset(double varianceOffset_relative,
        double varianceOffset_absolute)

        Set the offset to add to the covariance matrices.

        Parameters:
        -----------

        varianceOffset_relative:  offset to add to the diagonal of covariance
        matrices (relative to data variance)

        varianceOffset_absolute:  offset to add to the diagonal of covariance
        matrices (minimum value)

        Exceptions:
        -----------

        invalid_argument:  if the covariance offset is <= 0 
        """
        return _xmm.HierarchicalHMM_set_varianceOffset(self, varianceOffset_relative, varianceOffset_absolute)


    def get_weight_regression(self):
        """
        double
        HierarchicalHMM::get_weight_regression() const

        Get Regression Weight.

        Weight of the regresion part for synthesis 
        """
        return _xmm.HierarchicalHMM_get_weight_regression(self)


    def set_weight_regression(self, weight_regression):
        """
        void
        HierarchicalHMM::set_weight_regression(double weight_regression)

        Get Regression Weight.

        Parameters:
        -----------

        weight_regression:  Weight of the regresion part for synthesis 
        """
        return _xmm.HierarchicalHMM_set_weight_regression(self, weight_regression)


    def get_regression_estimator(self):
        """
        REGRESSION_ESTIMATOR HierarchicalHMM::get_regression_estimator() const

        Get the regression estimator type.

        regression estimator type

        See:  REGRESSION_ESTIMATOR 
        """
        return _xmm.HierarchicalHMM_get_regression_estimator(self)


    def set_regression_estimator(self, regression_estimator):
        """
        void HierarchicalHMM::set_regression_estimator(REGRESSION_ESTIMATOR
        regression_estimator)

        Set the regression estimator type.

        Parameters:
        -----------

        regression_estimator:  type of estimator

        See:  REGRESSION_ESTIMATOR 
        """
        return _xmm.HierarchicalHMM_set_regression_estimator(self, regression_estimator)


    def get_transitionMode(self):
        """
        string
        HierarchicalHMM::get_transitionMode() const

        get transition mode of the hidden Markov Chain

        string corresponding to the transition mode (left-right / ergodic) 
        """
        return _xmm.HierarchicalHMM_get_transitionMode(self)


    def set_transitionMode(self, transMode_str):
        """
        void
        HierarchicalHMM::set_transitionMode(string transMode_str)

        set transition mode of the hidden Markov Chain

        Parameters:
        -----------

        transMode_str:  string keyword corresponding to the transition mode
        ("left-right" / "ergodic")

        Exceptions:
        -----------

        invalid_argument:  if the argument is not "left-right" or
        "ergodic" 
        """
        return _xmm.HierarchicalHMM_set_transitionMode(self, transMode_str)


    def get_estimateMeans(self):
        """
        bool
        HierarchicalHMM::get_estimateMeans() const 
        """
        return _xmm.HierarchicalHMM_get_estimateMeans(self)


    def set_estimateMeans(self, _estimateMeans):
        """
        void
        HierarchicalHMM::set_estimateMeans(bool _estimateMeans) 
        """
        return _xmm.HierarchicalHMM_set_estimateMeans(self, _estimateMeans)


    def addExitPoint(self, state, proba):
        """
        void
        HierarchicalHMM::addExitPoint(int state, float proba) 
        """
        return _xmm.HierarchicalHMM_addExitPoint(self, state, proba)


    def get_learningMode(self):
        """
        string
        HierarchicalHMM::get_learningMode() const

        return learning mode: "incremental" or "ergodic"

        if ergodic, each time a model is added at the high level, the
        transition matrix is reset to ergodic. if "incremental", the
        transitions are updated using regularization learningMode
        "incremental" or "ergodic" 
        """
        return _xmm.HierarchicalHMM_get_learningMode(self)


    def set_learningMode(self, learningMode):
        """
        void
        HierarchicalHMM::set_learningMode(string learningMode)

        set learning mode: "incremental" or "ergodic"

        if ergodic, each time a model is added at the high level, the
        transition matrix is reset to ergodic. if "incremental", the
        transitions are updated using regularization

        Parameters:
        -----------

        learningMode:  "incremental" or "ergodic"

        Exceptions:
        -----------

        invalid_argument:  if the argument is neither "incremental" nor
        "ergodic" 
        """
        return _xmm.HierarchicalHMM_set_learningMode(self, learningMode)


    def get_prior(self, prior):
        """
        void
        HierarchicalHMM::get_prior(vector< double > &prior) const

        get a copy of the high-level Prior probabilities vector

        Parameters:
        -----------

        prior:  output High-level prior probability vector 
        """
        return _xmm.HierarchicalHMM_get_prior(self, prior)


    def set_prior(self, prior):
        """
        void
        HierarchicalHMM::set_prior(vector< double > const &prior)

        set high-level prior probabilities vector

        Parameters:
        -----------

        prior:  high-level probability vector (size nbPrimitives)

        Exceptions:
        -----------

        invalid_argument:  if the array has a wrong format (not enough values)

        WARNING:  the models are ordered in ascending order by label 
        """
        return _xmm.HierarchicalHMM_set_prior(self, prior)


    def get_transition(self, trans):
        """
        void
        HierarchicalHMM::get_transition(vector< double > &trans) const

        get a copy of the high-level transition matrix

        Parameters:
        -----------

        trans:  output high-level transition matrix 
        """
        return _xmm.HierarchicalHMM_get_transition(self, trans)


    def set_transition(self, trans):
        """
        void
        HierarchicalHMM::set_transition(vector< double > const &trans)

        set the high-level transition matrix

        Parameters:
        -----------

        trans:  high-level transition matrix

        Exceptions:
        -----------

        invalid_argument:  if the array has a wrong format (not enough values)

        WARNING:  the models are ordered in ascending order by label 
        """
        return _xmm.HierarchicalHMM_set_transition(self, trans)


    def get_exitTransition(self, trans):
        """
        void
        HierarchicalHMM::get_exitTransition(vector< double > &trans) const

        get a copy of the high-level exit probabilities

        exit probabilities are the probabilities to finish and go back to the
        root

        Parameters:
        -----------

        trans:  output exit transition vector of the high level 
        """
        return _xmm.HierarchicalHMM_get_exitTransition(self, trans)


    def set_exitTransition(self, exittrans):
        """
        void
        HierarchicalHMM::set_exitTransition(vector< double > const &exittrans)

        set the exit transition vector of the high level

        Parameters:
        -----------

        exittrans:  high-level exit probabilities vector

        Exceptions:
        -----------

        invalid_argument:  if the array has a wrong format (not enough values)

        WARNING:  the models are ordered in ascending order by label 
        """
        return _xmm.HierarchicalHMM_set_exitTransition(self, exittrans)


    def setOneTransition(self, srcSegmentLabel, dstSegmentLabel, proba):
        """
        void
        HierarchicalHMM::setOneTransition(Label srcSegmentLabel, Label
        dstSegmentLabel, double proba)

        set a particular value of the transition matrix

        sets trans(i,j) = proba

        Parameters:
        -----------

        srcSegmentLabel:  origin segment

        dstSegmentLabel:  target segment

        proba:  probability of making a transition from srcSegmentLabel to
        dstSegmentLabel

        WARNING:  transitions are normalized after the value is set. Todo
        absolute/relative mode? 
        """
        return _xmm.HierarchicalHMM_setOneTransition(self, srcSegmentLabel, dstSegmentLabel, proba)


    def remove(self, label):
        """
        void
        HierarchicalHMM::remove(Label const &label)

        Remove Specific model.

        The method updates the transition parameters

        Parameters:
        -----------

        label:  label of the model

        Exceptions:
        -----------

        out_of_range:  if the label does not exist 
        """
        return _xmm.HierarchicalHMM_remove(self, label)


    def performance_init(self):
        """
        void
        HierarchicalHMM::performance_init()

        Initialize performance mode. 
        """
        return _xmm.HierarchicalHMM_performance_init(self)


    def performance_update(self, observation):
        """
        void
        HierarchicalHMM::performance_update(vector< float > const
        &observation)

        Main performance Function: perform joint recognition and mapping (in
        the case of a bimodal model)

        Parameters:
        -----------

        observation:  observation vector. If the model is bimodal, this should
        be allocated for both modalities, and should contain the observation
        on the input modality. The predicted output will be appended to the
        input modality observation 
        """
        return _xmm.HierarchicalHMM_performance_update(self, observation)


    def to_json(self):
        """
        JSONNode
        HierarchicalHMM::to_json() const

        Write to JSON Node.

        JSON Node containing training set information and data 
        """
        return _xmm.HierarchicalHMM_to_json(self)


    def from_json(self, root):
        """
        void
        HierarchicalHMM::from_json(JSONNode root)

        Read from JSON Node.

        Parameters:
        -----------

        root:  JSON Node containing training set information and data

        Exceptions:
        -----------

        JSONException if the JSON Node has a wrong format 
        """
        return _xmm.HierarchicalHMM_from_json(self, root)

    __swig_setmethods__["prior"] = _xmm.HierarchicalHMM_prior_set
    __swig_getmethods__["prior"] = _xmm.HierarchicalHMM_prior_get
    if _newclass:
        prior = _swig_property(_xmm.HierarchicalHMM_prior_get, _xmm.HierarchicalHMM_prior_set)
    __swig_setmethods__["exitTransition"] = _xmm.HierarchicalHMM_exitTransition_set
    __swig_getmethods__["exitTransition"] = _xmm.HierarchicalHMM_exitTransition_get
    if _newclass:
        exitTransition = _swig_property(_xmm.HierarchicalHMM_exitTransition_get, _xmm.HierarchicalHMM_exitTransition_set)
    __swig_setmethods__["transition"] = _xmm.HierarchicalHMM_transition_set
    __swig_getmethods__["transition"] = _xmm.HierarchicalHMM_transition_get
    if _newclass:
        transition = _swig_property(_xmm.HierarchicalHMM_transition_get, _xmm.HierarchicalHMM_transition_set)
HierarchicalHMM_swigregister = _xmm.HierarchicalHMM_swigregister
HierarchicalHMM_swigregister(HierarchicalHMM)
HHMM_DEFAULT_EXITTRANSITION = cvar.HHMM_DEFAULT_EXITTRANSITION
HHMM_DEFAULT_INCREMENTALLEARNING = cvar.HHMM_DEFAULT_INCREMENTALLEARNING
HHMM_DEFAULT_REGULARIZATIONFACTOR = cvar.HHMM_DEFAULT_REGULARIZATIONFACTOR

# This file is compatible with both classic and new-style classes.


